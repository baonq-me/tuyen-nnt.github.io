---
layout: post
title:  "Tìm hiểu Network"
author: tuyennnt
categories: [ Network ]
image: assets/images/network-layer.png
---

## 1. Mô hình mạng 5 tầng
 ![](/assets/images/five-layer-network.png)
 
* Tầng 1: Physical 

Ví dụ như dây cáp mạng, hay các đầu nối, tín hiệu gửi để kết nối các máy tính với nhau. Ngoài ra tầng này còn mô tả cách tín hiệu được gửi qua các kết nối vật lý này.

* Tầng 2: Data Link

Dùng để diễn giải các tín hiệu của tầng 1 một cách chung chung để các thiết bị mạng có thể giao tiếp.
Có nhiều giao thức ở tầng này nhưng phổ biến nhất là Ethernet, có nhiệm vụ nhận dữ liệu và truyền đến các nodes trên cùng 1 mạng hoặc link. 
Tầng này nhận dữ liệu trên 1 đường liên kết đơn.


 * Tầng 3: Network (or Internet)
 ![](/assets/images/network-layer.png)
 Là tầng cho phép các mạng khác nhau liên kết với nhau thông qua các thiết bị router (bộ định tuyến). 
 Tập hợp các mạng kết nối với nhau thông qua router gọi là Internetwork (mạng liên kết). Mạng liên kết phổ biến nhất là ``Internet`` :D.
 Tầng này chịu trách nhiệm nhận dữ liệu được phân phối từ 1 tập hợp các mạng.
Giao thức phổ biến nhất ở tầng này là giao thức IP (Internet protocol).

Một phần mềm mạng gồm ``Client`` và ``Server``:

* Client gửi request
* Server thì gửi về response

Một node có thể chạy nhiều chương trình client hoặc server cùng lúc.
Kiểu như ở client (server host) của bạn cùng thao tác nhiều chương trình cùng lúc để request (như mail, trình duyệt web), thì server ngoài cũng có thể chạy nhiều chương trình để trả về response cho bạn. 
 
* Tầng 4: Transport

Trong khi tầng Network cung cấp dữ liệu giữa 2 node riêng lẻ thì tầng Transport có nhiệm vụ phân loại ra chương trình client hay server nào có nhiệm vụ nhận dữ liệu đó.

Giao thức phổ biến nhất ở tầng này chính là TCP (Transmission Control Protocol). Người ta hay gọi theo cụm là TCP IP. 
> Nhưng TCP IP ko phải là tên gọi của 1 giao thức, nó chỉ là tên gọi chung kết hợp của giao thức ở tầng 3 và tầng 4. Mỗi giao thức đều có công dụng khác nhau.

Ngoài ra có 1 giao thức thuộc tầng 4 transport cũng sử dụng giao thức IP tầng 3 để truyền tải dữ liệu. Đó là giao thức UDP (User Datagram Protocol). Nhưng giao thức này không đảm bảo độ tin cậy bằng TCP, mình sẽ nói thêm ở mục sau.

Tóm lại, các giao thức ở tầng này hầu hết có nhiệm vụ đảm bảo dữ liệu được truyền tải đến "đúng" các ứng dụng đang chạy trên các nút đó. 


* Tầng 5: Application 

Giao thức phổ biến ở tầng này là HTTP (cho phép chúng ta duyệt web), SMTP (gửi/nhận email), etc..


#### Tóm tắt: Giải thích 1 cách dễ hiểu hơn:
![](/assets/images/layer-actual.png) 

* Tầng 1: Chiếc xe tải
* Tầng 2: Mô tả cách xe tải đi từ giao lộ này đến giao lộ kia.
* Tầng 3: Xác định đường để đi từ địa chỉ A đến địa chỉ B để giao hàng.
* Tầng 4: Đảm bảo là tài xế biết cách gõ cửa nhà để biết đến đúng địa chỉ nhà rồi và thông báo ra nhận gói tin.
* Tầng 5: Chính là nội dung của gói hàng (dữ liệu) !

#### Có thể bạn chưa biết?

* Ngoài model 5 tầng còn nhiều model khác. Nổi tiếng nhất là OSI model (7 tầng), khác với loại 5 tầng mà chúng ta học ở chỗ tầng 5 được tách ra 3 tầng.
* TCP/IP truyền thống chỉ có 4 tầng vì Tầng 1 và tầng 2 được gộp làm 1. Về cơ bản cái truyền thống 4 tầng và 5 tầng hiện nay không khác nhau là mấy.
* Chúng ta có thể tìm hiểu thêm về OSI Model tại đây:
```
https://www.sans.org/reading-room/whitepapers/standards/osi-model-overview-543

https://en.wikipedia.org/wiki/OSI_model
```

## 2. Tầng 1 - Các thiết bị mạng cơ bản

### Cable
Dùng để kết nối các thiết bị với nhau và cho phép truyền dữ liệu thông qua nó.

Giúp tạo kết nối mạng đơn giữa 1 điểm với 1 điểm.

Có 2 loại:

* Copper cable: Cat3, Cat5, Cat5e, Cat6,...
![](cooper-cable.png)
	* Các cable đời mới hơn như Cat5e, Cat6 tốt hơn trong việc truyền dữ liệu nhiều hơn và chính xác hơn do chúng có thông số kỹ thuật nâng cao và lõi xoắn của chúng được cấu tạo khác đi để giảm sự xuyên âm (crosstalk- khi mà xung điện trên 1 dây được phát hiện trên 1 dây khác) giúp giảm tình trạng đầu nhận dữ liệu không hiểu được dữ liệu gây ra lỗi mạng.
	* Gửi giao tiếp dữ liệu nhị phân qua dây đồng bằng cách thay đổi điện áp giữa 2 phạm vi. Hệ thống ở đầu nhận dữ liệu sẽ dịch sự thay đổi điện áp này thành dữ liệu nhị phân 0-1. Sau đó từ dữ liệu 0-1 này sẽ được dịch sang các loại dữ liệu khác nhau.
	* Sử dụng áp điện để biểu diễn dữ liệu dưới dạng 0-1

* Fiber optic
	* Sử dụng xung ánh sáng để biểu diễn dữ liệu dưới dạng 0-1.
	* Được dùng ưu tiên cho các môi trường có nhiều nhiễu điện từ.
	* Vận chuyển dữ liệu nhanh hơn, khoảng cách xa hơn mà khó làm mất dữ liệu tiềm ẩn hơn.
	* Đắt và dễ vỡ hơn.
	
	
### Hub & Switch 
Là những thiết bị giúp kết nối các máy tính trong cùng 1 mạng, thường gọi là mạng LAN (mạng cục bộ) 

#### Hub
1 thiết bị bất kỳ trong mạng lưới của hub khi truyền dữ liệu tới hub sẽ kết nối đến tất cả các máy tính khác mà cùng được kết nối với hub. 

![](/assets/images/hub.png) 

Các máy tính nhận dữ liệu có hệ thống riêng để xác định xem dữ liệu đó có đúng là dữ liệu mà nó có nhiệm vụ nhận hay không. Nếu không thì trả về không, nếu có thì thông báo nhận thành công.

Cơ chế này gây ra nhiều tiếng ồn (noise) tạo ra cái gọi là collision domain.

Collision domain:

* Một phân đoạn mạng mà chỉ có 1 thiết bị có thể giao tiếp tại 1 thời điểm.
![](/assets/images/collision.png) 

* Nếu nhiều hệ thống (máy tính) cố gắng gởi dữ liệu cùng 1 lúc, các xung điện được gởi qua cáp (cable) có thể gây nhiễu lẫn nhau.
Khiến cho các hệ thống phải chờ đợi một khoảng thời gian yên tĩnh trước khi cố gắng gửi dữ liệu lần nữa.

> Điều này làm chậm truyền thông mạng nên hiện nay Hub không còn được dùng phổ biến.

### Switch
Mô hình hoạt động tương đối giống Hub, khác biệt ở chỗ:

* Hub ở layer 1, Switch ở layer 2 (Data Link device) 
* Do đó Switch có thể kiểm tra dữ liệu của giao thức Ethernet được gửi đi xung quanh network. 
=> Switch có thể xác định hệ thống (máy tính) nào thuộc về dữ liệu đó mà chỉ gửi thẳng đến hệ thống đó thôi.

![](/assets/images/switch.png)

> Điều này giúp loại bỏ hoàn toàn kích thước của collision domain trong network.
Gíup giảm sự truyền tải lại và tăng thông lượng tổng thể.

### Router
Là thiết bị biết các forward dữ liệu giữa các mạng độc lập với nhau.

![](/assets/images/router.png)

* Hoạt động ở lớp thứ 3 (Network)

* Cũng giống như switch, router có thể kiểm tra dữ liệu IP để xác định địa chỉ cần gửi dữ liệu đến.

* Router chứa 1 số bảng nội bộ chứa các thông tin về định tuyến traffic (lưu lượng truy cập) giữa nhiều mạng khác nhau trên thế giới. Phổ biến là các router gia đình hoặc văn phòng nhỏ. Mục đích của các bộ định tuyến nhỏ này chỉ để lấy lưu lượng truy cập có nguồn gốc từ trong nhà hoặc văn phòng nhỏ sử dụng LAN và chuyển tiếp nó đến ISP (nhà cung cấp dịch vụ Internet)

![](/assets/images/router-isp.png)

* ISP là một loại router phức tạp hơn nhiều, nó sẽ tiếp quản traffic từ router nhỏ. Router này gọi là router lõi, tạo thành xương sống của Internet, chịu trách nhiệm về cách gửi và nhận dữ liệu khắp thế giới mỗi ngày.

* ISP tiếp nhận rất nhiều traffic và phải xử lý việc quyết định nơi nào là nơi gửi traffic này đến. Core router này thường có nhiều kết nối đến nhiều core router khác bằng giao thức BGP (Border Gateway Protocol) giúp chúng tìm hiểu xem đường nào là tối ưu nhất để chuyển lưu lượng truy cập đến.

> Khi bạn mở trình duyệt truy cập đến 1 web server bất kỳ, traffic giữa máy tính và web server có thể đã đi qua hàng chục router khác nhau. 
Các Router là những hướng dẫn viên toàn cầu giúp đưa traffic đến đúng nơi.


## Server và Client

Nodes: là từ dùng để gọi chung cho các thiết bị trong network ở trên, có thể là máy tính, server, client hay router,...

Server: là node có nhiệm vụ cung cấp data cho client, còn được dùng để chỉ mục đích chính của node trên mạng.

Client: là node request data.

Đôi khi 1 node vừa làm server vừa là client. Ví dụ như Email server, vừa cung cấp data về email cho client, mà vừa là 1 client gửi yêu cầu đến DNS server và được DNS trả data về.

=> Hầu hết các thiết bị không hoàn toàn là 1 server hay 1 client, mà đảm nhận 1 trong 2 vị trí trên ở 1 thời điểm.

![](/assets/images/server-client.png)


## 3. Tầng 2 - Data Link Layer

### Ethernet 
* Là protocol mạng phổ biến nhất ở tầng 2 để gửi dữ liệu qua các liên kết riêng lẻ. (còn Wi-Fi thì dạng khác)
* Là phương tiện giúp trừu tượng hóa tầng 1 (vật lý hay phần cứng) để các tầng khác có thể dễ tiếp cận sử dụng.
* Chịu trách nhiệm về các thông tin kết nối, liên kết thiết bị để các tầng trên dựa vào. Vì vậy, các tầng trên không cần quan tâm thiết bị được kết nối ra sau, mà chỉ quan tâm tầng dưới gửi dữ liệu gì để xử lý mà thôi.
* Ethernet có 1 kỹ thuật là CSMA/CD (Carrier-sense multiple access with collision detection) giúp nhận biết "collision domain" sóng mang xung đột. 
* CSMA/CD được dùng để quyết định khi nào kênh giao tiếp đang rãnh rỗi trên phân đoạn mạng (network segment) và khi nào 1 thiết bị đang rãnh để truyền dữ liệu.
> Cách hoạt động khá đơn giản, khi có xung đột thì lập tức dừng truyền dữ liệu của các thiết bị gặp xung đột và chờ 1 khoảng thời gian ngẫu nhiên giúp tránh vụ va chạm (random interval trước khi thử gửi lại, và không đồng thời).

* Phân đoạn mạng của tất cả các thiết bị được kết nối sẽ có tất cả thông tin, dữ liệu đang trao đổi. Do đó, ta cần xác định thiết bị nào là nơi dữ liệu cần đến bằng MAC Address. 

### MAC Addresses (Media Access Control Address)

* Là địa chỉ để nhận diện toàn cầu được đính kèm với một network interface cá nhân.
* Giúp nhận dạng các máy tính khác nhau.
* Là một con số **48-bit** thường được biểu diễn bởi 6 nhóm với 2 con số hệ thập lục phân cho mỗi nhóm.
* Nghĩa là sẽ có tối đa 2^48 MAC address.
> Hệ thập lục phân là cách biểu diễn các số sử dụng 16 ký tự. 
![](/assets/images/hexa.png)


* Octet: là 1 cách để tham chiếu số MAC. Trong mạng máy tính, bất kỳ số nào có thể biểu diễn bằng 8 bits được gọi là Octet.
=> 2 chữ số thập lục phân có thể biểu diễn các số tương tự các số được biểu diễn bằng 8 bits.

* 03 Octets đầu tiên của địa chỉ MAC được gọi là OUI (Organizationally unique identifier), được gán cho nhà sản xuất phần cứng riêng lẻ.
=> Từ 3 octets đầu có thể giúp ta xác định được NSX.
* 03 Octets sau được chỉ định theo ý nhà sản xuất mong muốn với điều kiện để mỗi thiết bị sản xuất ra có 1 MAC address duy nhất.
![](/assets/images/mac-1.png)

* Tóm lại, Ethernet protocol dùng MAC address để đảm bảo dữ liệu mà nó gửi có thông tin thiết bị nguồn và thiết bị đích gửi đến. Bằng cách này, dù ở trong một phân đoạn mạng hoạt động như thể có collision domain đơn lẻ, thì các thiết bị luôn biết được khi nào dữ liệu thuộc về nó. 

### Unicast, Multicast & Broadcast frame
#### Unicast
Là sự truyền tải data đến 1 địa chỉ đích duy nhất.

Được nhận diện bằng cách nhìn vào bit ít quan trọng nhất trong octet đầu tiên của địa chỉ MAC đích trong Ethernet frame.

* Nếu là 0 : unicast
* Nếu là 1 : multicast
 
#### Multicast
Là sự truyền tải data đến nhiều địa chỉ MAC đích.

Các thiết bị mạng (network interface) có thể được cấu hình để chấp nhận 1 danh sách địa chỉ MAC được nhận data & giao tiếp trong network cục bộ.

#### Broadcast
Ethernet broadcast address : FF:FF:FF:FF:FF:FF

Broadcast được sử dụng để tất cả các thiết bị có thể hiểu lẫn nhau.

Người gửi sẽ gửi tới tất cả các thiết bị trên mạng LAN.

### Ethernet Frame

* Data-packet: là 1 concept chung để chỉ 1 tập hợp dữ liệu nhị phân được gửi thông qua network link.

* Là 1 tập hợp (data-packet) các thông tin mang tính tổ chức cao, biểu diễn theo 1 thứ tự cụ thể.

* Bằng Ethernet frame, network interface có tại tầng 1 có thể chuyển đổi chuỗi bit qua một liên kết (data link) để cho ra 1 data có ý nghĩa (decode).

![](/assets/images/line-coding.png)

* Các phần trong frame là bắt buộc và có độ dài cố định.

![](/assets/images/ethernet-frame.png)


Thứ tự và các thành phần của Ethernet Frame gồm:

* Preamble (8 bytes): phần mở đầu, chia làm 7 bytes đệm + 1 byte SDF (dùng để làm dấu giới hạn khung bắt đầu, sau nó là khung dữ liệu thực tế).
Phần này được các network interface dùng để đồng bộ hóa các đồng hồ nội bộ mà chúng sử dụng nhằm điều chỉnh speed tại nơi mà chúng gởi dữ liệu.
* Destination MAC Address (48 bits/6 bytes): địa chỉ phần cứng đích, là bên nhận data.
* Source Address (6 bytes):  địa chỉ MAC nguồn.
* VLAN header (4 bytes): nếu trong khung có 4 bytes này thì nghĩa là đây là VLAN frame. Nếu có VLAN, thì sau nó phải có EtherType field. 
> VLAN (Virtual LAN) là kỹ thuật cho phép ta có nhiều LAN hoạt động trên cùng 1 thiết bị vật lý (switch,..). VLAN được sử dụng để tách biệt traffic truy cập khác nhau với các thiết bị cùng mạng kết nối.

![](/assets/images/vlan.png)

* EtherType field (2 bytes): được dùng để diễn giải protocol (giao thức) của nội dung dữ liệu.

* Payload (từ 46-1500 bytes): là data chính cần được vận chuyển, chứa data tầng 3,4,5.

* FCS (4 bytes): viết tắt của Frame Check Sequence, là 1 con số có độ dài 32 bit, biểu diễn checksum value cho toàn bộ ethernet frame.

	* Checksum value: được tính bằng cách biểu diễn chu kỳ kiểm tra dự phòng (CRC) trên frame.

	* Cyclical redundancy check (CRC): là một khái niệm quan trọng đối với tính toàn vẹn dữ liệu (data integrity), và được dùng cho toàn bộ các tính toán học, không chỉ riêng truyền tải network. Đây là 1 phép toán học sử dụng phân chia đa thức để tạo ra 1 con số đại diện cho 1 tập dữ liệu lớn hơn và luôn kết thúc bằng 1 số checksum.

=> Mục đích của checksum là để kiểm tra xem data bên đầu nhận có bị hỏng không.

Quy trình thực hiện:

* Thiết bị sẵn sàng lên frame để gửi đi
* Thiết bị bắt đầu thu thập đủ các thông tin cần có của 1 frame (trừ checksum)
* Thực hiện CRC trên các thông tin đó và gắn số checksum thu được.
* Đưa FCS vào frame hoàn chỉnh.
* Đưa frame vào một data link dùng protocol Ethernet
* Đầu thiết bị bên nhận thu thập các trường dữ liệu nhận được và tính toán lại checksum để so sánh với số checksum của frame gởi.
Nếu không khớp nhau, nó sẽ vứt ra ngoài vì trong quá trình truyền đã khiến data bị hỏng.
=> Và nhiệm vụ của tầng trên sẽ quyết định xem data đó có nên được truyền lại hay không. 
=> Kết luận: bản thân Ethernet chỉ báo cáo cho tầng trên biết về tính toàn vẹn của dữ liệu, chứ không có nhiệm vụ phục hồi dữ liệu.

Cụ thể hình ảnh cho quy trình:
![](/assets/images/CRC.png)
Sau đó đưa vào link và bên nhận nhận được, rồi bên nhận sẽ tính toán lại số checksum:
![](/assets/images/checksum.png)


## 4. Tầng 3 - Network
### IP Address

* Là một con số 32-bit được tạo thành từ 4 octet. Mỗi octet có độ dài 8-bit và biểu diễn dưới dạng số thập phân từ 0 đến 255.

Ví dụ: 12.34.56.78

* Các tổ chức lớn thường sử dụng IP address để xác định máy nào hơn là sử dụng MAC address để truyền tải dữ liệu trong mạng.
=> IP có phân cấp rõ ràng và lưu trữ dữ liệu dễ dàng hơn.

> Ví dụ công ty IBM có octet đầu được cấp riêng là 9. Thì khi router từ sender gửi dữ liệu thấy số 9 ở octet đầu của địa chỉ IP nhận (IP là 9.0.0.1 chẳng hạn), nó sẽ biết là cần gửi đến router của IBM, sau đó router của IBM sẽ tự xử lý phân phối dữ liệu đến các máy tính trong network của IBM thông qua các octet còn lại.

* Lưu ý: IP address thuộc về networks, chứ không thuộc về thiết bị được kết nối với các network.
> Nghĩa là network (mạng) khác nhau sẽ có nhiệm vụ cấp phát IP khác nhau cho thiết bị của bạn bằng công nghệ DHCP khi bạn bật mạng của network đó.


* DHCP hay còn gọi là Dynamic IP Address (địa chỉ IP động) được dùng để cấp phát IP động cho các clients. 
* Static IP Address thì thường được dùng để cấp phát IP tĩnh cho server và các thiết bị mạng (router,...)

### IP Datagrams & Encapsulation
#### IP Datagram
* Là data-packet (gói tin) ở tầng network theo giao thức IP.

* 2 phần chính của IP datagram là header và payload.
![](/assets/images/ip-datagram.png)

Ý nghĩa các trường trong datagram header:

* Version (4-bit): version của Internet protocol.
Ví dụ: IP version 4 thì Internet protocol là IPv4.

*  Header Length (4-bit): ghi số độ dài của header, thường là 20 bytes đối với IPv4. 20 byte cũng là độ dài tối thiểu của IP header.

* Service Type (8-bit): chi tiết về chất lượng dịch vụ, hoặc QoS, các công nghệ áp dụng.

* Total Length (16-bit): tổng chiều dài của IP datagram.
=> Kích thước tối đa là con số lớn nhất có thể biểu diễn bằng 16 bits là 65,535.
=> Nếu kích thước lớn hơn con số tối đa mà network hiện tại cho phép, IP layer sẽ chia làm các data-packet (gói tin/datagram) nhỏ hơn.

* Identification (16-bit): là số 16 bit được dùng để group các messages lại với nhau.
=> Trường này giúp nhóm các gói tin bị tách ra lại với nhau thành 1 phần của đường truyền.

*  Flags (4-bit): chỉ ra rằng datagram này có được phép phân mảng hay không, hoặc đã được phân mảnh chưa. 

* Fragment Offset (12-bit): là quá trình phân mảnh datagram ra các datagram nhỏ hơn (nếu vượt quá giới hạn của network nó đang được truyền đến).

* Time to Live - TTL (8-bit): là trường chỉ ra bao nhiêu bước nhảy để 1 datagram có thể đi đến IP đích trước khi bị vứt đi. Đến số 0 thì router biết được là nó ko cần forward data nữa.
![](/assets/images/TTL.png)
Mục đích của bước này là để đảm bảo khi có cấu hình sai trong router gây ra vòng lặp vô tận như hình:
![](/assets/images/TTL-loop.png)

* Protocol (8-bit): thông tin về transport layer protocol được sử dụng ở gói tin này. (TCP, UDP,...)

* Header checksum (16-bit): số checksum nội dung của toàn bộ IP datagram header.
=> Checksum phải được tính toán lại mỗi lần TTL chạm 1 bộ định tuyến (vì có IP thay đổi)

* Source & Destination IP Address (32-bit) : địa chỉ IP nguồn và IP đích.

* Options: trường tùy chọn được dùng để thiết lặp các đặc tính đặc biệt cho datagram được dùng chủ yếu cho các mục đích testing. Trường này có độ dài biến đổi.

* Padding: thường dùng khi có trường Option. Là chuỗi số 0 để đảm bảo kích thước của header đúng kích thước tổng.


#### Encapsulation
Phần data payload section của Ethernet frame sẽ là toàn bộ IP datagram.

Quá trình gôm các data trong IP datagram lại với nhau thành frame gọi là encapsulation (tương tự payload của Ethernet frame).

* Toàn bộ data của IP datagram được đóng gói lại làm payload cho tầng ngay dưới nó (tầng 2), đó gọi là quá trình encapsulation. Các tầng khác cũng hoạt động như thế.

* Tầng sau đó sẽ dùng toàn bộ payload của tầng trước đó.

![](/assets/images/encapsulation.png)

### IP Address Classes

Là cách xác định cách địa chỉ global IP phân chia không gian.

* Class A: octet đầu là network ID, 3 octet sau là host ID.

* Class B: 2 octet đầu là network ID, 2 octet sau là host ID.

* Class C: 3 octet đầu là network ID, octet cuối là host ID.

![](/assets/images/ip-class.png)

### Address Resolution Protocol (ARP)

Là giao thức được dùng để khám phá địa chỉ MAC của một node với địa chỉ IP tương ứng.

Các thiết bị mạng sẽ lưu giữ 1 bảng ARP local chứa thông tin địa chỉ MAC ứng với IP của các thiết bị mạng đã từng kết nối (trong 1 khoảng thời gian nhất định).

Thiết bị truyền sẽ tìm đến địa chỉ đích bằng cách phát tín hiệu ``broadcast`` FF:FF:FF:FF:FF:FF cho tất cả các máy tính trong mạng local rằng tôi muốn tìm địa chỉ MAC của máy có địa chỉ IP này.

Máy có địa chỉ IP đó sẽ lên tiếng và gửi ARP response chứa địa chỉ MAC lại cho sender (thiết bị truyền).

Giờ thì thiết bị truyền có thể đưa MAC address vào Ethernet frame để truyền tải dữ liệu.

### Subnetting 

Là quá trình tách network lớn thành nhiều network nhỏ hơn gọi là các subnetworks hoặc subnets.

![](/assets/images/subnetting.png)

#### Subnet Mask

* IP: 9.100.100.100

* Subnet mask: 255.255.255.224

* Subnet mask in binary: 11111111 11111111 11111111 11100000

=> 9.100.100.100/27
> Có 27 số 1 (các số 1 này là subnet ID).


![](/assets/images/subnet-id.png)
Hình trên là ví dụ của subnet mask: 255.255.255.0


Subnet mask là cách để máy tính sử dụng toán tử AND để xác định địa chỉ IP đó có tồn tại trên cùng network hay không.


#### CIDR (/ notation)
Là một cách tiếp cận linh hoạt để cung cấp số lượng địa chỉ IP phù hợp với nhu cầu. CIDR cho phép network tự phân chia kích thước.
![](/assets/images/subnet-2.png)

Nó dựa vào subnet để Demarcate (phân định).

Demarcation point là cách để mô tả nơi 1 network hay system kết thúc và cái khác bắt đầu.

Một IP thường có Network ID, Subnet ID, Host ID.
Tuy nhiên với CIDR, Network ID và Subnet ID thường được kết hợp làm một. 

> Nếu công ty cần nhiều hơn 1 class C số lượng địa chỉ IP max mà class C có thể cung cấp (254). Thay vì tạo 2 class C để gấp đôi thì giờ đây với CIDR, nó chỉ cần kết tnoosi không gian địa chỉ liên tục với nhau với mask /23 hay có thể nói là 255.255.254.0.

Giờ đây router chỉ cần biết 1 entry trong routing table để vận chuyển lưu lượng đến các địa chỉ đích thay vì 2.

> Trước đây network ID là tĩnh và chỉ có class A,B,C để phân định kích thước cố định và chỉ có subnet mới có thể thay đổi. Với CIDR thì mọi chuyện đã khác.

![](/assets/images/CIDR-23.png)

Phân tích hình trên 1 chút:

* Hãy nhớ là ta sẽ luôn mất 2 host ID trên mỗi mạng. (giá trị đầu và cuối trong range) 

* Nếu không dùng CIDR, ta cần 2 network class C nên = 254+254
IDR
* /23 nghĩa là thêm được 1 bit cho Host ID = 2^9


### Routing (lộ trình) 
#### Concept

* Định nghĩa Router: Là thiết bị mạng chuyển tiếp traffic phụ thuộc vào địa chỉ đích của traffic đó.
Router thường có 2 network interface giúp nó có thể vận chuyển traffic giữa 2 network với nhau.

![](/assets/images/routing.png)

Lộ trình ở hình trên sẽ được lặp lại cho đến khi traffic đến được địa chỉ đích.

![](/assets/images/routing-2.png)

Diễn giải hình trên như sau:

* Máy tính có IP 192.168.1.100 (máy A) muốn gửi gói tin đến máy có IP 10.0.0.10 (máy B)
* Máy A nằm trong Network A và biết rằng máy B không nằm trong local Network A.
* Máy A gửi gói tin này đến địa chỉ MAC của gateway của nó là Router A có IP gateway là 192.168.1.1.
* Router interface trên Network A nhận được gói tin vì nó thấy địa chỉ MAC đích trên Ethernet frame thuộc về nó. Sau đó, nó bỏ đi phần header của tầng Data-link để đưa đến tầng 3 phân tích tiếp.
* Router sẽ trực tiếp kiểm tra header của IP datagram ở tầng 3. Nó tìm thấy IP đích chính là 10.0.0.10 thuộc về mạng B (10.0.0.0/24) trong Routing Table.
Mạng B có interface kết nối với router này.
* Tiếp theo Router sẽ tạo 1 gói tin mới để gửi cho Network B bằng cách sao chép dữ liệu IP datagram nhưng giảm trường TTL xuống 1 đơn vị + tính toán giá trị checksum mới.
* Sau đó đóng gói IP datagram mới này bên trong 1 Ethernet frame mới với địa chỉ MAC đích là địa chỉ MAC của IP 10.0.0.10 của network B mà nó lưu sẵn trong ARP table.
* Và cuối cùng gói tin sẽ được gửi ra khỏi interface của router trên Network B để đến với máy B.

![](/assets/images/routing-3.png)

* Máy A muốn gửi đến máy C phải thông qua router interface của máy A trên Network B và router interface của máy C trên Network B.
* Cụ thể là máy A sau khi thấy IP đích không thuộc local network thì sẽ gửi đến gateway của nó là Router A thì router A này kiểm tra trong routing table thấy cách nhanh nhất là gửi gói tin đến router B để đến với máy C.
* Sau đó router A sẽ -1 bước nhảy cho trường TTL và gửi cho router B thông qua router interface của router A trên network B và router interface của router B trên network B.
* Do network của máy C được kết nối trực tiếp với router B thông qua router interface thuứ 2 của router B. Nên router B sẽ gửi thẳng gói tin đến máy C trên Network C và kết thúc lộ trình. 

#### Routing table
* Cơ bản nhất sẽ có 4 cột. Trong đó có cột Network. Các cột còn lại có thể là IP, Subnet Mask hay CIDR. 
* Sẽ có từng hàng cho từng Network mà router này biết.
* Khi nhận được gói tin, router sẽ biết IP đích đó thuộc network nào dựa vào routing table của nó.
* Routing table sẽ luôn có 1 mục chung (catchall entry) cho bất kỳ địa chỉ IP nào không có network rõ ràng.

* Next hop: là địa chỉ IP của router tiếp theo sẽ nhận dữ liệu
* Total hops: tổng số bước nhảy còn lại được tính toán đường đi ngắn nhất (sử dụng thuật toán) để đưa gói tin đến đích.

* Các routing table sẽ luôn được update thông tin mới về đường dẫn nhanh nhất đến mạng đích. 

#### Gateway Protocol 
Router sử dụng Routing Protocol để nói chuyện với các Router khác để chia sẻ thông tin với nhau, tìm ra con đường ngắn nhất để chia sẻ gói tin,...

Routing protocol có 2 loại : 
* Interior Gateway Protocol
* Exterior Gateway Protocol

##### Interior Gateway Protocol
Được router sử dụng để chia sẻ thông tin trong 1 hệ thống autonomous đơn (1 tổ chức điều hành mạng).

Autonomous system là tập hợp các Network dưới sự quản lý của 1 nhà điều hành mạng duy nhất. 
> Ví dụ như 1 tập đoàn cần routing traffic mạng của họ giữa các office của họ và mỗi office có thể có 1 local network. Hoặc ví dụ khác là 1 tổ chức nhà mạng lớn của quốc gia quản lý các router thuộc nhà mạng đó.

![](/assets/images/interior-protocol.png)

Interior Gateway Protocol bao gồm 2 loại:

* Distance-vector protocol (tiêu chuẩn cũ)
Router dựa vào danh sách khoảng cách giữa các network trong routing table của router dưới dạng bao nhiêu hops, sau đó gửi danh sách này cho các router lân cận bằng Distance-vector protocol. Do đó các router lân cận có thể đoán được đường đi nào nhanh hơn.
=> Router sẽ được cập nhật routing table thường xuyên.
![](/assets/images/distance-protocol.png)

* Link state routing protocol
![](/assets/images/link-state.png)
Giao thức này có cách tiếp cận tinh vi hơn. Từng router trong autonomous system sẽ broadcast thông tin của nó đến tất cả các router còn lại, và chúng sẽ có hết thông tin của nhau.
Các router sẽ chạy các thuật toán phức tạp để tìm đường đi ngắn nhất đến địa chỉ đích.
Do vậy cần bộ nhớ nhiều hơn và bộ xử lý tốn kém hơn. 

> Khi phần cứng trở nên mạnh mẽ hơn đã khiến giao thức vector trước đó trở nên cũ và lạc hậu.

##### Exterior Gateway Protocol
Được sử dụng bởi các Edge router của tổ chức cần chia sẻ thông tin với các tổ chức điều hành mạng khác.
> Đây là chìa khóa chính của Internet vì Internet là mạng lưới khổng lồ của các autonomous system.

Ở mức cao nhất sẽ có một Core internet router nắm giữ thông tin của các autonomous system. Nhiệm vụ chính của nó là đưa dữ liệu vào Edge Router của các autonomous system.

![](/assets/images/core-router.png)
