<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Memoirs</title>
    <description>I will take you on the fabulous world of exploration. Travel, culture, lifestyle. Eat, Pray, Love!</description>
    <link>/tuyen-nnt.github.io/</link>
    <atom:link href="/tuyen-nnt.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 16 Aug 2021 01:35:20 +0700</pubDate>
    <lastBuildDate>Mon, 16 Aug 2021 01:35:20 +0700</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Setup Jekyll themes</title>
        <description>&lt;h2 id=&quot;fork-jekyll-theme--play&quot;&gt;Fork Jekyll theme &amp;amp; Play&lt;/h2&gt;

&lt;p&gt;Đây là theme blog mình đang sử dụng: https://github.com/tuyen-nnt/jekyll-theme-memoirs&lt;/p&gt;

&lt;p&gt;Các bước build Jekyll cho blog này: https://bootstrapstarter.com/jekyll-theme-memoirs/
(Tìm hiểu thêm tại: https://jekyllrb.com/docs/)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B1: git clone https://github.com/wowthemesnet/jekyll-theme-memoirs.git&lt;/li&gt;
  &lt;li&gt;B2: Tải Ruby https://www.ruby-lang.org/en/documentation/installation/&lt;/li&gt;
  &lt;li&gt;B3: cd vào thư mục theme rồi &lt;code&gt;gem install bundler&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;B4: &lt;code&gt;bundle install&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Kết quả build thành công:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/bundle-install.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;B5: Sửa lại &lt;code&gt;_config.yml&lt;/code&gt; theo blog của mình&lt;/li&gt;
  &lt;li&gt;B6: &lt;code&gt;bundle exec jekyll serve --watch&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;B7: Xem web blog tại http://127.0.0.1:4000/jekyll-theme-memoirs (nếu folder vẫn giữ tên cũ)&lt;/li&gt;
  &lt;li&gt;B8: Thêm blogs định dạng &lt;code&gt;.md&lt;/code&gt; vào folder &lt;code&gt;_posts&lt;/code&gt;. Trước mỗi bài viết sẽ có ô YAML là định dạng chung, bạn chỉ cần điền vào thông tin của mình là được (nhưng vẫn giữ form nhé). Chi tiết xem link các bước thực hiện.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tìm hiểu về Bundler install: https://bundler.io/&lt;/p&gt;

&lt;p&gt;Tìm hiểu về Gemfile: https://bundler.io/gemfile.html&lt;/p&gt;

</description>
        <pubDate>Tue, 10 Aug 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/Jekyll-install/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/Jekyll-install/</guid>
        
        
        <category>Git</category>
        
        <category>Blog</category>
        
        <category>Web</category>
        
      </item>
    
      <item>
        <title>Python - Part 2</title>
        <description>&lt;h4 id=&quot;1-dictionaries&quot;&gt;1. Dictionaries&lt;/h4&gt;
&lt;p&gt;Là tập hợp các cặp &lt;code&gt;key:value&lt;/code&gt; khi cần kết nối dữ liệu với nhau như 1 table để tra cứu nhanh và có thể chỉ ra unique keys khi tra cứu, thay vì nối 2 list lại để lấy index rồi tra cứu value.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;So sánh giữa list và dict:
&lt;img src=&quot;img/list-vs-dict.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cú pháp tạo dict như sau:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;my_dict = {
	key:value,
	key:value
}&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Access dict như sau:
&lt;code&gt;my_dict['key']&lt;/code&gt; =&amp;gt; cho ra value của key đó.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Thêm key:value vào dict:
&lt;code&gt;world[&quot;sealand&quot;] = 0.25&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Check xem dict đã được thêm key ở trên vào chưa: 
&lt;code&gt;sealand in world&lt;/code&gt; =&amp;gt; trả về True/False.
Với ‘seadland’ là key và word là tên dict.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cập nhật lại giá trị cho key &lt;code&gt;sealand&lt;/code&gt;:
&lt;code&gt;world['sealand'] = 0.28&lt;/code&gt;
Vì key trong dict là unique nên Python hiểu là bạn muốn thay đổi giá trị chứ không phải tạo mới cặp key:value.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Xóa cặp key:value:
&lt;code&gt;del(world['sealand'])&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dict trong dict:
Cũng như list có thể chứa list trong list. Xem ví dụ:&lt;/p&gt;
    &lt;pre&gt;&lt;code&gt;# Dictionary of dictionaries
europe = { 'spain': { 'capital':'madrid', 'population':46.77 },
         'france': { 'capital':'paris', 'population':66.03 },
         'germany': { 'capital':'berlin', 'population':80.62 },
         'norway': { 'capital':'oslo', 'population':5.084 } }
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;Để access giá trị của dict, ta sẽ dùng dấu [] như trong array:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;europe['spain']['population']&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;=&amp;gt; Vậy để add thêm cặp key:dict vào trong dict trên thì làm thế nào?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Create sub-dictionary data
data = {
    'capital':'rome',
    'population':59.83
}

# Add data to europe under key 'italy'
europe['italy'] = data
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ta chỉ cần tách ra tạo dict phụ trước và gán nó vào biến lưu object value. Sau đó ta thêm cặp key:value vào dict như bình thường.&lt;/p&gt;

&lt;p&gt;Lưu ý:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Keys không được trùng nhau trong 1 dict, vì nếu trùng, nó sẽ chỉ lấy giá trị cuối cùng.&lt;/li&gt;
  &lt;li&gt;Keys phải là immutable object (không đổi), còn list thì mutable nên list cũng không được là key trong dict.&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-pandas&quot;&gt;2. Pandas&lt;/h4&gt;

&lt;h5 id=&quot;tabular-dataset-trong-python&quot;&gt;Tabular dataset trong Python&lt;/h5&gt;
&lt;p&gt;row = observations&lt;/p&gt;

&lt;p&gt;column = variable&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Để làm việc với dạng data này thì cần cấu trúc dạng chữ nhật.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; 2D Numpy array&lt;/p&gt;

&lt;p&gt;=&amp;gt; Nhưng với các dữ liệu có nhiều thông tin với nhiều datatype khác nhau như str, float,… thì Numpy chưa hiệu quả.&lt;/p&gt;

&lt;p&gt;Vậy nên pandas package chính là solution và quen thuộc trong Data science.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nó được build dựa trên Numpy.&lt;/li&gt;
  &lt;li&gt;Là tool ở cấp độ cao trong thao tác với dữ liệu.&lt;/li&gt;
  &lt;li&gt;Pandas lưu dữ liệu bảng trong object gọi là Dataframe.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cách tạo dataframe từ dictionary:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import pandas as pd
brics = pd.DataFrame(dict)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/create-df.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Để tạo index cho observations trong df, ta dùng attribute &lt;code&gt;index&lt;/code&gt; và gán 1 list với thứ tự chính xác các index mong muốn:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;brics.index = [...,...]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;img/index-df.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h5 id=&quot;csv-file&quot;&gt;CSV file&lt;/h5&gt;
&lt;p&gt;Nhưng thực tế trong Data science, ta phải đối mặt với lượng data khổng lồ tùy trường hợp cụ thể, nên thông thường ta không tự tạo dataframe. Giả sử các data đến từ file có &lt;code&gt;.csv&lt;/code&gt; viết tắt của comma separated values.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Để import vào môi trường Python ta dùng cú pháp:&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;brics = pd.read_csv(&quot;path/to/brics.csv&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Tuy nhiên đối với file có index, khi import vào thì cột index đầu tiên sẽ bị ngầm hiểu là cột đầu của dữ liệu chính. Để tránh điều này, ta phải thêm argument &lt;code&gt;index_col=0&lt;/code&gt;, kết quả:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/csv-import.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Để thay đổi index tự động từ 0-n bằng label được định nghĩa trong 1 list tạo riêng tự chọn, ta dùng cú pháp:
```
    &lt;h1 id=&quot;definition-of-row_labels&quot;&gt;Definition of row_labels&lt;/h1&gt;
    &lt;p&gt;row_labels = [‘US’, ‘AUS’, ‘JPN’, ‘IN’, ‘RU’, ‘MOR’, ‘EG’]&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;specify-row-labels-of-cars&quot;&gt;Specify row labels of cars&lt;/h1&gt;
&lt;p&gt;cars.index = row_labels&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
##### Cách để access Dataframe
Ta input vào label hoặc index của column hoặc row. Ví dụ cụ thể ta có df là cars, xem cú pháp dưới đây: 

* Access COLUMN (cột):
	* Dùng [] : 
	- Nếu muốn output là Series object: ``cars['country', ... ]``
	- Nếu muốn output là Dataframe, dùng double ngoặc vuông:
``cars[['country', ... ]]``
&amp;gt; Nhìn ở góc khác, ta đang input vào ngoặc vuông 1 list chứa column labels.

	* Dùng ``loc`` (chọn 1 phần data dựa trên label-based) hoặc ``iloc`` (chọn data dựa trên integer position-based)
	- cars.loc['country', ...] hoặc cars.loc[['country', ...]] 
	- car.iloc[0, ..., ...] hoặc car.iloc[[0, ..., ...]]
	
* Access ROW (quan sát)	
	* Chỉ có cách là dùng [] nhưng input vào số:
	- Nếu muốn lấy row từ index 1 đến 3:
``cars[1:4]`` 
	* Dùng loc hoặc iloc và input vào index của row thay vì tên cột như truy cập vào column.

* Access ROWs &amp;amp; COLUMNs bất kì:
	* Sử dụng loc và iloc tiện lợi:
	- Ta chỉ cần đặt vào label của row và column trong loc hoặc iloc theo thứ tự ``row, column``. 
	- Nếu chọn nhiều hơn 1 label trong row hoặc column, ta biến argument row hoặc column thành list.

Xem	 hình ví dụ:
	
![](img/loc-iloc.png)

	
&amp;gt; Nhận xét: 

- Dấu ngoặc vuông``[]`` có giới hạn chức năng và lý tưởng nhất là sử dụng trong 2D Numpy array để access value dễ dàng nhất.	
- Nếu muốn dấu``[]``có thể mở rộng khả năng access value trong pandas như  dấu``[]``trong 2D Numpy array, thì ta cần sử dụng ``loc`` và ``iloc``.

![](img/iloc-loc.png)
	
	
##### Filter dataframe

* Bước 1: Access cột trả về series object.

* Bước 2: Xác định điều kiện filter và trả về Boolean Series. Nếu &amp;gt; 2 điều kiện thì phải sử dụng Numpy variants của toán tử and, or, not.

* Bước 3: Dùng Boolean Series là kết quả của bước 1 làm input trong dấu ngoặc vuông của Dataframe. Kết quả trả về các record thỏa điều kiện.

&amp;gt; You'll want to build up a boolean Series, that you can then use to subset the cars DataFrame to select certain observations. If you want to do this in a one-liner, that's perfectly fine!


#### 3. LOOP

##### WHILE


##### FOR 

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;for var in seq :
	expression&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
Trong đó ``var`` là biến bất kỳ có thể đặt tên sao cũng được. Python dùng nó để quét lần lượt cái phần tử trong ``seq``.


FOR còn dùng để lặp từng char trong string.
![](img/string-loop.png)

* enumerate() : cung cấp 2 giá trị cho mỗi lần lặp gồm ``index`` và ``value (giá trị)``.

![](img/enumerate-for.png)



Mỗi data structure sẽ có cách loop các nhau và cách định nghĩa sequence khác nhau (seq). Cụ thể các bạn xem dưới đây nhé:

##### Loop với List của Lists 
* Nếu list mà bạn cần lặp là list của list, thì dùng cách như sau:

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;house-list-of-lists&quot;&gt;house list of lists&lt;/h1&gt;
&lt;p&gt;house = [[“hallway”, 11.25], 
         [“kitchen”, 18.0], 
         [“living room”, 20.0], 
         [“bedroom”, 10.75], 
         [“bathroom”, 9.50]]&lt;/p&gt;

&lt;h1 id=&quot;build-a-for-loop-from-scratch&quot;&gt;Build a for loop from scratch&lt;/h1&gt;
&lt;h1 id=&quot;x-quét-từng-list-trong-list-dùng--để-truy-cập-phần-tử-của-sub-list&quot;&gt;x quét từng list trong list, dùng [] để truy cập phần tử của sub-list&lt;/h1&gt;

&lt;p&gt;for x in house :
    print(“the “ + x[0] + “ is “ + str(x[1]) + “ sqm”)
```&lt;/p&gt;

&lt;h5 id=&quot;loop-với-dictionary&quot;&gt;Loop với Dictionary&lt;/h5&gt;
&lt;p&gt;Sử dụng method &lt;code&gt;items()&lt;/code&gt; :&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for key, val in my_dict.items() :&lt;/code&gt;&lt;/p&gt;

&lt;h5 id=&quot;loop-với-numpy-array&quot;&gt;Loop với Numpy array&lt;/h5&gt;
&lt;p&gt;Sử dụng function &lt;code&gt;np.nditer(my_array)&lt;/code&gt; đặc biệt là với 2D array.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;for val in np.nditer(my_array) :&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Với 1D array ta có thể sử dụng loop thông thường, nhưng với 2D thì nó sẽ in ra 2D array thay vì ra các giá trị cần lấy trong loop.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Dùng &lt;code&gt;nditer&lt;/code&gt; sẽ giúp in ra từng giá trị từ trái sang phải từ trên xuống dưới của 2D array.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;pandas-dataframe&quot;&gt;Pandas DataFrame&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;iterrows()&lt;/code&gt; : Trong mỗi lần lặp, method này sẽ generate ra 2 giá trị:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Label của row (nếu ko có thì là index tự động)&lt;/li&gt;
  &lt;li&gt;Data của row (là Pandas Series có index/label là tên cột - còn gọi là fieldname)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/iterrows.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Để loop in ra giá trị của cột mong muốn cho mỗi lần lặp, ta chỉ cần:&lt;/p&gt;

&lt;p&gt;print(row[“tên cột”])&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Thêm cột vào Dataframe bằng loop:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ví dụ ta muốn thêm cột tính độ dài của cột “country”:
&lt;code&gt;brics.loc[lab, &quot;tên cột mới&quot;] = len(row[&quot;country&quot;])&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/new-col.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Nhận xét: Cách này tốt trong trường hợp ít record. Vì ta đang tạo ra Series object cho mỗi vòng lặp và nó sẽ không hiệu quả với các dataset khổng lồ, thậm chí gây ra vấn đề khi xử lý dữ liệu.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Vậy nên, cách tốt nhất là ta sử dụng function &lt;code&gt;apply(tên function)&lt;/code&gt; cho mỗi cột mà ta muốn tính toán rồi gán vào cột mới trong dataframe:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;brics[&quot;cột mới&quot;] = brics[&quot;country&quot;].apply(len)&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Cách hoạt động: Function &lt;code&gt;apply()&lt;/code&gt; sẽ gọi function &lt;code&gt;len()&lt;/code&gt; mà mỗi giá trị của cột country sẽ là input để tính độ dài từng country. Kết quả trả về là 1 array mà chúng ta có thể dễ dàng lưu thành cột mới trong Dataframe.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Mon, 02 Aug 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/python-intermediate/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/python-intermediate/</guid>
        
        
        <category>Data</category>
        
        <category>Programing</category>
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Import Data - Part 2</title>
        <description>&lt;h4 id=&quot;1-import--load--tạo-httpget-request&quot;&gt;1. Import + Load + Tạo HTTP/GET REQUEST&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Lưu file mềm xuống local:
&lt;code&gt;urlretrieve(url, 'filename.csv')&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Trước tiên phải &lt;code&gt;from urllib.request import urlretrieve&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mở và đọc file mềm trên web:
&lt;code&gt;
df = pd.read_csv(url, sep=';')
&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Show các dòng đầu tiên của df:
&lt;code&gt;
print(df.head())
&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;URL (Uniform/Universal Resource Locator)
phần lớn là các địa chỉ web, ngoài ra còn là FTP (file transfer protocol)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URL gồm 2 phần:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Protocol Identifier : http hoặc https&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tên resource: datacamp.com
=&amp;gt; tạo thành 1 địa chỉ web&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;HTTP (HyperText Transfer Protocol)
Là protocol ứng dụng cho các hệ thống thông tin phân tán, cộng tác và siêu phương tiện, nền tảng giao tiếp dữ liệu cho WWW.
HTTPS - có độ an toàn bảo mật cao hơn HTTP&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Mỗi khi truy cập vào 1 trang web nghĩa là bạn đang gửi 1 HTTP request cho 1 server. Request này được gọi là GET request, đây là loại request phổ biến nhất.&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;urlretrieve : gửi GET request và lưu dữ liệu xuống local máy&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;HTML (HyperText Markup Language)&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;2-các-cách-gửi-get-request&quot;&gt;2. Các cách gửi GET request:&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Cách 1&lt;/strong&gt;: sử dụng &lt;code&gt;urllib.request&lt;/code&gt;
=&amp;gt; &lt;code&gt;from urllib.request import urlopen, Request&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Một số functions của package &lt;code&gt;urllib.request&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code&gt;request = Request(url)&lt;/code&gt; : đóng gói GET request&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;response = urlopen(request)&lt;/code&gt; : 
gửi request và catch phản hồi =&amp;gt; trả về HTTP response object có tích hợp method read() và close()&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;html = response.read()&lt;/code&gt; : trả về HTML định dạng string&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code&gt;response.close()&lt;/code&gt;: dùng xong nhớ đóng lại&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Cách 2&lt;/strong&gt;: rất phổ biến, sử dụng package &lt;code&gt;requests&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cho phép gửi HTTP request có tổ chức mà ko cần làm thủ công&lt;/p&gt;

&lt;p&gt;requests.get(url) : sau khi import package requests, hàm request.get() sẽ đóng gói request thông qua url, gửi request đi và nhận lại phản hồi và lưu vào biến r.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Ở đây hàm &lt;code&gt;request.get()&lt;/code&gt; sẽ làm nhiệm vụ của &lt;code&gt;Request(url)&lt;/code&gt; và &lt;code&gt;urlopen(request đã đóng gói)&lt;/code&gt;của cách 1&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;r.text : r là biến lưu response của hàm trên, sử dụng method .text cho response để chuyển HTML của url sang dạng string.&lt;/p&gt;

&lt;h4 id=&quot;3-scraping-web-trong-python&quot;&gt;3. Scraping web trong Python&lt;/h4&gt;

&lt;p&gt;HTML là sự kết hợp của data có cấu trúc và không cấu trúc.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Hàm &lt;code&gt;BeautifulSoup()&lt;/code&gt; có tác dụng parse và trích xuất data từ HTML, và làm cho các tag được biểu diễn đẹp hơn.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cách sử dụng: 
&lt;code&gt;from bs4 import BeautifulSoup&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Sau khi gửi nhận phản hồi của GET request, ta được file html như trên.&lt;/p&gt;

&lt;p&gt;Sau đó, ta dùng hàm &lt;code&gt;BeautifulSoup&lt;/code&gt; để extract các data có cấu trúc của file html, lưu kết quả là một object vào một biến mới. Kết quả của hàm &lt;code&gt;BeautifulSoup&lt;/code&gt;có tích hợp hàm &lt;code&gt;.prettify()&lt;/code&gt; để làm đẹp kết quả.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;soup = BeautifulSoup(html_doc)
print(soup.prettify())&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Các hàm khác có thể dùng sau khi parse và nhận kết quả từ BeautifulSoup:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;&lt;code&gt;soup.title()&lt;/code&gt; : trích title của file html&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;soup.get_text()&lt;/code&gt;: trích tất cả text của file html&lt;/li&gt;
      &lt;li&gt;&lt;code&gt;soup.find_all()&lt;/code&gt; : tìm tất cả các data theo điều kiện hoặc tag nào đó.
  Ví dụ:
        &lt;pre&gt;&lt;code&gt;  for link in soup.find_all('a'):
  print(link.get('href')
&lt;/code&gt;&lt;/pre&gt;
        &lt;p&gt;hoặc&lt;/p&gt;
        &lt;pre&gt;&lt;code&gt;  for link in a_tags:
  print(link.get('href'))
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;=&amp;gt; Ở đây, ta sử dụng vòng lặp for kết hợp hàm &lt;code&gt;.find_all()&lt;/code&gt; extract data nằm trong tag &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; của file html và in ra từng link của mỗi dòng tìm được, ta cũng có thể lưu &lt;code&gt;soup.find_all()&lt;/code&gt; vào một biến nào đó.
Hàm &lt;code&gt;link.get('href')&lt;/code&gt; dùng để extract giá trị link của attribute href trong tag &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&quot;4-load-và-khám-phá-file-json&quot;&gt;4. Load và khám phá file JSON&lt;/h4&gt;
&lt;h6 id=&quot;file-json-nằm-ở-local&quot;&gt;FIle JSON nằm ở local&lt;/h6&gt;

&lt;ul&gt;
  &lt;li&gt;Bước 1: Tạo connection với file JSON trong local và load file
    &lt;pre&gt;&lt;code&gt;with open(&quot;tên file.json&quot;) as json_file :
  json_data = json.load(json_file)
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;Ở đây json_data là 1 object dictionary, ta check bằng &lt;code&gt;type(json_data)&lt;/code&gt; ra kết quả &lt;code&gt;dict&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Bước 2: Sử dụng vòng lặp &lt;code&gt;for&lt;/code&gt; để in cặp key-value ra
    &lt;pre&gt;&lt;code&gt;for k in json_data.keys():
  print(k + ': ', json_data[k])
&lt;/code&gt;&lt;/pre&gt;
    &lt;p&gt;Từ object dictionary trên, ta dùng àm &lt;code&gt;.keys&lt;/code&gt; để truy cập vào keys của file và dùng cú pháp &lt;code&gt;dictionary[key]&lt;/code&gt; để truy cập vào value.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;5-apis-và-tương-tác-cơ-bản&quot;&gt;5. APIs và tương tác cơ bản&lt;/h4&gt;

&lt;h5 id=&quot;api-là-gì&quot;&gt;API là gì?&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Là một bộ protocols và routines để xây dựng và tương tác với phần mềm&lt;/li&gt;
  &lt;li&gt;Một tập hợp code cho phép 02 chương trình phần mềm giao tiếp với nhau
Ví dụ nếu muốn stream data của Twitter thì ta cùng API của Twitter.&lt;/li&gt;
  &lt;li&gt;Thông thường data thường được lấy về từ APIs ở định dạng JSON.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;url-có-gì-và-làm-thể-nào-để-nó-biết-pull-data-từ-api-về&quot;&gt;URL có gì và làm thể nào để nó biết pull data từ API về?&lt;/h5&gt;

&lt;p&gt;&lt;code&gt;url = 'http://www.omdbapi.com/?t=hackers'&lt;/code&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;http - dấu hiệu là ta đang tạo 1 HTTP request&lt;/li&gt;
  &lt;li&gt;www.omdbapi.com - nghĩa là ta đang query OMDB API&lt;/li&gt;
  &lt;li&gt;&lt;code&gt;?t=hackers&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;Đây gọi là Query String&lt;/li&gt;
      &lt;li&gt;Không có quy ước và không buộc có trong đường dẫn&lt;/li&gt;
      &lt;li&gt;Sau dấu &lt;code&gt;?&lt;/code&gt; là phần query. Theo document trên trang chủ OMDB API thì có nghĩ là ta đang muốn trả về data của bộ phim có title (t) ‘Hackers’. Cụ thể xem phần Usage + Parameters.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# Import package
import requests

# Assign URL to variable: url
url = 'https://en.wikipedia.org/w/api.php?action=query&amp;amp;prop=extracts&amp;amp;format=json&amp;amp;exintro=&amp;amp;titles=pizza'

# Package the request, send the request and catch the response: r
r = requests.get(url)

# Decode the JSON data into a dictionary: json_data
json_data = r.json()

print(json_data)

# Print the Wikipedia page extract
pizza_extract = json_data['query']['pages']['24768']['extract']
print(pizza_extract)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ở 2 dòng code cuối, để biết tại sao code như thế, ta truy cập url trên browser, nó sẽ hiện ra các tab. Ta muốn extract data từ api của url thì ta mở từ tab &lt;code&gt;query &amp;gt; pages &amp;gt; 24768 &amp;gt; extract&lt;/code&gt; thì sẽ nhận được data từ api đó.&lt;/p&gt;

&lt;h5 id=&quot;load-và-khám-phá-twitter-data&quot;&gt;Load và khám phá Twitter data&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# Import package
import json

# String of path to file: tweets_data_path
tweets_data_path = 'tweets.txt'

# Initialize empty list to store tweets: tweets_data
tweets_data = []

# Open connection to file
tweets_file = open(tweets_data_path, &quot;r&quot;)

# Read in tweets and store in list: tweets_data
for line in tweets_file:
    tweet = json.loads(line)
    tweets_data.append(tweet)

# Close connection to file
tweets_file.close()

# Print the keys of the first tweet dict
print(tweets_data[0].keys())
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Đầu tiên ta gán đường dẫn tên file chứa Twitter data ở local máy vào 1 biến.&lt;/li&gt;
  &lt;li&gt;Tiếp theo ta tạo 1 mảng rỗng để chứa mỗi dòng tweet là 1 phần tử trong mảng.&lt;/li&gt;
  &lt;li&gt;Sau đó ta mở connection đến file local đó thông qua dường dẫn &lt;code&gt;tweets_data_path&lt;/code&gt; và lưu vào &lt;code&gt;tweets_file&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;Tiếp theo ta dùng vòng lặp for để đọc từng dòng của &lt;code&gt;tweets_file&lt;/code&gt;:
    &lt;ul&gt;
      &lt;li&gt;Dùng hàm &lt;code&gt;json.load(line)&lt;/code&gt; để load từng dòng lưu vào biến &lt;code&gt;tweet&lt;/code&gt;, &lt;em&gt;để dùng hàm trên phải import &lt;code&gt;json&lt;/code&gt; package&lt;/em&gt;
        &lt;blockquote&gt;
          &lt;p&gt;Note: mỗi lần load &lt;code&gt;line&lt;/code&gt; để lưu vào &lt;code&gt;tweet&lt;/code&gt; là một dictionary.&lt;/p&gt;
        &lt;/blockquote&gt;
      &lt;/li&gt;
      &lt;li&gt;Sử dụng biến mảng &lt;code&gt;tweets_data&lt;/code&gt; kết hợp hàm &lt;code&gt;append(tweet)&lt;/code&gt; để add thêm phần tử dictionary mới (hay còn gọi là tweet) vào mảng.&lt;/li&gt;
      &lt;li&gt;In ra tất cả các &lt;code&gt;keys&lt;/code&gt; của phần tử đầu tiên (tweet hay dict) của mảng.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;đưa-mảng-vào-dataframe-sử-dụng-package-pandas-để-phân-tích&quot;&gt;Đưa mảng vào Dataframe sử dụng package pandas để phân tích&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;# Import package
import pandas as pd

# Build DataFrame of tweet texts and languages
df = pd.DataFrame(tweets_data, columns=['text','lang'])
 
# Print head of DataFrame

print(df.head())
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Hàm &lt;code&gt;pd.Dataframe()&lt;/code&gt; cần 2 tham số là data và column để xây dựng df
    &lt;ul&gt;
      &lt;li&gt;Tham số đầu có thể là mảng, dict hoặc dataframe&lt;/li&gt;
      &lt;li&gt;Tham số thứ 2 là column label, nếu không có label thì dùng RangeIndex(0,1,2,…n). Nếu có label trong data như ví dụ trên, ta chỉ cần &lt;code&gt;columns=['text','lang']&lt;/code&gt; để chọn label cho column muốn rút giá trị. Ở ví dụ trên ta sẽ tạo 2 cột &lt;code&gt;text&lt;/code&gt; và &lt;code&gt;lang&lt;/code&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;streaming&quot;&gt;Streaming&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;# Initialize Stream listener
l = MyStreamListener()

# Create your Stream object with authentication
stream = tweepy.Stream(auth, l)

# Filter Twitter Streams to capture data by the keywords:
stream.filter(track=['clinton', 'trump', 'sanders', 'cruz'])
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Class &lt;code&gt;MyStreamListener()&lt;/code&gt; được khai báo sẵn tại đây: https://gist.github.com/hugobowne/18f1c0c0709ed1a52dc5bcd462ac69f4&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Ta tạo object &lt;code&gt;stream&lt;/code&gt;bằng cách đưa vào hàm &lt;code&gt;tweepy.Stream()&lt;/code&gt; athentication handler &lt;code&gt;auth&lt;/code&gt; và object &lt;code&gt;l&lt;/code&gt; - stream listener trên.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Object &lt;code&gt;stream&lt;/code&gt; có tích hợp hàm &lt;code&gt;.filter()&lt;/code&gt;, trong hàm này có attribute &lt;code&gt;track=[]&lt;/code&gt; là list chứa các keyword mà ban muốn filter.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;phân-tích-data-cơ-bản&quot;&gt;Phân tích data cơ bản&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;import re

def word_in_text(word, text):
    word = word.lower()
    text = text.lower()
    match = re.search(word, text)

    if match:
        return True
    return False
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Ở trên ta có hàm &lt;code&gt;word_in_text()&lt;/code&gt; để đếm số lượng tweet chứa keyword. Nhưng ở đây chúng ta chưa đếm, mà chỉ đưa kết quả nếu True sẽ +1 vào biến đếm ở bước tiếp theo.&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# Initialize list to store tweet counts
[clinton, trump, sanders, cruz] = [0, 0, 0, 0]

# Iterate through df, counting the number of tweets in which
# each candidate is mentioned
for index, row in df.iterrows():
    clinton += word_in_text('clinton', row['text'])
    trump += word_in_text('trump', row['text'])
    sanders += word_in_text('sanders', row['text'])
    cruz += word_in_text('cruz', row['text'])
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Tiếp theo ta sẽ tạo list trong Python, mỗi item sẽ có giá trị đếm bắt đầu =0. Mục đích ở đây là để đếm số tweet count được cho mỗi keyword.&lt;/li&gt;
  &lt;li&gt;Sử dụng vòng lặp để đi từng row và check, nếu gặp keyword sẽ +1 vào biến đếm. Nếu True (nghĩa là có keyword đó) thì += 1.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;basic-data-visualization&quot;&gt;Basic Data visualization&lt;/h5&gt;

&lt;pre&gt;&lt;code&gt;# Import packages
import seaborn as sns
import matplotlib.pyplot as plt


# Set seaborn style
sns.set(color_codes=True)

# Create a list of labels:cd
cd = ['clinton', 'trump', 'sanders', 'cruz']

# Plot the bar chart
ax = sns.barplot(cd, [clinton, trump, sanders, cruz])
ax.set(ylabel=&quot;count&quot;)
plt.show()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Đầu tiên cần import 2 package như trên để vẽ biểu đồ&lt;/li&gt;
  &lt;li&gt;Hàm &lt;code&gt;sns.barplot()&lt;/code&gt; có 2 tham số:
    &lt;ul&gt;
      &lt;li&gt;Tham số đầu: list label cần biểu diễn giá trị&lt;/li&gt;
      &lt;li&gt;Tham số thứ 2: list chứa giá trị của các label cần biểu diễn. List này đã được khởi tạo và đếm ở code trước đó.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sun, 18 Jul 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/import-data-medium/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/import-data-medium/</guid>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>Python - Part 1</title>
        <description>&lt;h4 id=&quot;i-list&quot;&gt;I. LIST&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Thêm phần tử cho list:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Chỉ cần + [list]&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
y = x + [&quot;e&quot;, &quot;f&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
  &lt;li&gt;Xóa phần tử list:&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Dùng del(phần tử). Lưu ý là khi xóa thì các phần tử ở sau bị đẩy index lên.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
del(x[1])
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Dấu [index:index] trong list
    &lt;ul&gt;
      &lt;li&gt;x[start:end]
  Với start là chỉ số lấy
  end chỉ số không lấy
Ví dụ:&lt;/li&gt;
      &lt;li&gt;x[2:5] : lấy giá trị của index từ 2 đến 4&lt;/li&gt;
      &lt;li&gt;x[:3] : từ đầu đến index 2&lt;/li&gt;
      &lt;li&gt;x[3:] : từ index 3 đến hết&lt;/li&gt;
      &lt;li&gt;x[:] : lấy hết phần tử&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Dấu &lt;code&gt;;&lt;/code&gt;:
Dùng để tách command code trên cùng 1 dòng, nếu khác dòng thì không cần.
```
    &lt;h1 id=&quot;same-line&quot;&gt;Same line&lt;/h1&gt;
    &lt;p&gt;command1; command2&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;separate-lines&quot;&gt;Separate lines&lt;/h1&gt;
&lt;p&gt;command1
command2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
* Copy list:
Khi copy kiểu ``x=y`` thì thực tế ta đang copy địa chỉ list của y cho x. Nghĩa là khi ta thay đổi phần tử trong x thì y cũng thay đổi theo.

Để xử lý tình huống này, nếu chỉ muốn copy giá trị list thì ta dùng: ``x = list(y)`` hoặc ``x = y[:]``


* Convert datatype
x = str(y)
x = int(y)
x = float(y)
&amp;gt; Check datatype bằng function ``type()``

* Xem cấu trúc của 1 function có sẵn:
``help(max)`` hoặc ``?max``

#### II. METHOD
* Cũng là function nhưng dành cho từng type
* Tất cả mọi thứ trong Python đều là object.
* Object có các method riêng, phụ thuộc vào data type 

#### III. Numpy
Tại sao dùng Numpy?
*  Rất quyền lực, có thể sử dụng cho nhiều data type khác nhau. Tuy nhiên mỗi tập hợp (array) chỉ được chứa 1 loại data type.
* Có thể thêm, xóa, sửa
* Quan trọng trong Data Science
	* Làm các phép toán cho các tập hợp
	* Tốc độ nhanh
* Ta thấy nếu áp dụng phép toán như -*/ trên kiểu dữ liệu list thì sẽ throw Error ``không hỗ trợ``. Nếu + thì sẽ ghép 2 list lại thành 1 list.
&amp;gt; Tuy nhiên, ta đang cần +-*/ trên 2 list theo index tương ứng. Thì Numpy sẽ giúp ta giải quyết khó khăn này.

Giải pháp Numpy có gì?
* Python kiểu số. Có hàm ``np.mean()`` và ``np.median()`` rất phổ biến trong data science.
* Thay thế cho Python List : kiểu dữ liệu ``Numpy Array``
* Giúp tính toán trên toàn bộ array
* Nhanh và dễ dàng
* Cài đặt trong terminal: 
``pip3 install numpy``

Như vậy, để thực hiện các phép toán trên list, ta phải chuyển nó sang kiểu dữ liệu Numpy Array như sau:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;import numpy as np
np_height = np.array(height)
np_weight = np.array(weight)
bmi = np_weight / np_height ** 2&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
**Lưu ý quan trọng:**

* Mỗi array chỉ được chứa 1 loại data type.
* Type khác nhau thì hành vi của nó sẽ khác nhau. VD: 

	* Phép + 2 list thì là ghép 2 list thành 1. 
	* Phép + 2 array thì là cộng theo giá trị index tương ứng của 2 array với nhau.

##### 1. Numpy Subsetting 
* Ta có array ``bmi``.
* Để truy cập vào array ta dùng cú pháp: ``bmi[index]``
* Để xét các giá trị trong array có thỏa điều kiện không, ta dùng: ``bmi &amp;gt; 23``
&amp;gt; Trả về array có kiểu Boolean (True/False)
* Để trả về array chứa các giá trị thỏa điều kiện, ta dùng: ``bmi[bmi &amp;gt; 23]`` 

##### 2. Type của Numpy array
Nếu ``print(type(np_height))``
&amp;gt; numpy.ndarray

Với numpy là package, n là layer của array. ndarray là kiểu dữ liệu chỉ sử dụng trong Numpy.

##### 3. 2D Numpy Arrays 
Cách tạo 2D array bằng 2 array:
* array1
* array2
* meas = np.array([array1, array2])


Có thể xem 2D numpy array như phiên bản nâng cấp của &quot;list của list&quot; vì ta có thể thực hiện các phép toán với nó.

Để tạo array 2D, ta chỉ cần input các giá trị vào như dưới đây, input 1 list có 2 sub-list vào argument của method ``np.array`` theo cấu trúc hình chữ nhật:
![](img/2d-array.png)

Mỗi sub-list là một row của array.  
Nếu ta thay đổi kiểu dữ liệu của bất kỳ giá trị nào trong array sang kiểu khác như từ float sang string, thì mặc nhiên numpy sẽ chuyển tất cả các giá trị còn lại sang string (in ra sẽ thấy).
&amp;gt; Vì mỗi numpy array chỉ chứa 1 kiểu dữ liệu.

Để biết cấu trúc data của array như thế nào, ta dùng attribute ``shape`` của array:
![](img/array-shape.png)
 *Vì là attribute nên nó không có ``()`` như method~*

Có 2 cú pháp để truy cập giá trị:
![](img/2d-subset.png)

* Cách 1: np_2d[row][column]
* Cách 2: np_2d[row,column]
* Dấu ``:`` vẫn sẽ được sử dụng giống như 1D array ở trên nếu muốn chọn cụ thể vùng giá trị muốn lấy.

*Với row, column là index, chú ý ở đây vẫn sử dụng zero-index cho 2D array.*


##### 4. Toán tử Boolean trong Numpy
Với Numpy array ta có thể sử dụng phép so sánh như các ví dụ trên, nhưng nếu sử dụng kết hợp and, or, not thì sẽ throw Error.
Do vậy, ta phải sử dụng:

* np.logical_and()
* np.logical_or() 
* np.logical_not()

Ex:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;np.logical_and(my_house &amp;gt; 13, 
               your_house &amp;lt; 15)&lt;/p&gt;

&lt;h1 id=&quot;kết-quả-trả-về-1-boolean-series-thích-hợp-dùng-để-filter-dataframe&quot;&gt;Kết quả trả về 1 Boolean Series, thích hợp dùng để filter dataframe&lt;/h1&gt;
&lt;p&gt;```
Với my_house và your_house là 2 Numpy array.&lt;/p&gt;
</description>
        <pubDate>Sun, 11 Jul 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/python-basic/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/python-basic/</guid>
        
        
        <category>Data</category>
        
        <category>Programing</category>
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>(ENG) The basics of Spark</title>
        <description>&lt;p&gt;Deciding whether or not Spark is the best solution for your problem takes some experience, but you can consider questions like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Is my data too big to work with on a single machine?
Can my calculations be easily parallelized?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bước 1: Create an instance of the SparkContext class to connect to a Spark cluster from PySpark.
You may also find that running simpler computations might take longer than expected. That’s because all the optimizations that Spark has under its hood are designed for complicated operations with big data sets. That means that for simple or small problems Spark may actually perform worse than some other solutions!&lt;/p&gt;

&lt;h1 id=&quot;verify-sparkcontext&quot;&gt;Verify SparkContext&lt;/h1&gt;
&lt;p&gt;print(sc)&lt;/p&gt;

&lt;h1 id=&quot;print-spark-version&quot;&gt;Print Spark version&lt;/h1&gt;
&lt;p&gt;print(sc.version)&lt;/p&gt;

&lt;p&gt;&amp;lt;SparkContext master=local[*] appName=pyspark-shell&amp;gt;
2.3.1&lt;/p&gt;

&lt;p&gt;Using DataFrames&lt;/p&gt;

&lt;p&gt;Spark’s core data structure is the Resilient Distributed Dataset (RDD). This is a low level object that lets Spark work its magic by splitting data across multiple nodes in the cluster. However, RDDs are hard to work with directly, so in this course you’ll be using the Spark DataFrame abstraction built on top of RDDs.&lt;/p&gt;

&lt;p&gt;The Spark DataFrame was designed to behave a lot like a SQL table (a table with variables in the columns and observations in the rows). Not only are they easier to understand, DataFrames are also more optimized for complicated operations than RDDs.&lt;/p&gt;

&lt;p&gt;When you start modifying and combining columns and rows of data, there are many ways to arrive at the same result, but some often take much longer than others. When using RDDs, it’s up to the data scientist to figure out the right way to optimize the query, but the DataFrame implementation has much of this optimization built in!&lt;/p&gt;

&lt;p&gt;To start working with Spark DataFrames, you first have to create a SparkSession object from your SparkContext. You can think of the SparkContext as your connection to the cluster and the SparkSession as your interface with that connection.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;I. SELECT&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Loai 2
    &lt;blockquote&gt;
      &lt;p&gt;flights.select(flights.air_time/60)&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;returns a column of flight durations in hours instead of minutes.&lt;/p&gt;

&lt;p&gt;if you wanted to .select() the column duration_hrs (which isn’t in your DataFrame) you could do&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;flights.select((flights.air_time/60).alias(“duration_hrs”))&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The equivalent Spark DataFrame method .selectExpr() takes SQL expressions as a string:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;flights.selectExpr(“air_time/60 as duration_hrs”)
with the SQL as keyword being equivalent to the .alias() method. To select multiple columns, you can pass multiple strings.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 27 Jun 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/spark/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/spark/</guid>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>Data Visualization</title>
        <description>&lt;h4 id=&quot;1-các-loại-chart-cơ-bản&quot;&gt;1. Các loại chart cơ bản&lt;/h4&gt;

&lt;p&gt;BAR CHART &amp;amp; COLUMN CHART&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Giúp ta nhìn vào giá trị cụ thể cho mỗi loại&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Có 4 loại:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Stacked bar và column chart
    &lt;blockquote&gt;
      &lt;p&gt;Biểu đồ chồng nhau theo giá trị,&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Clustered bar và column chart
    &lt;blockquote&gt;
      &lt;p&gt;Biểu đồ nhiều cột trong 1 phân loại&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;100% stacked bar và column chart
    &lt;blockquote&gt;
      &lt;p&gt;Biểu đồ chồng theo %&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Combo chart
    &lt;blockquote&gt;
      &lt;p&gt;Biểu đồ kết hợp cột và biểu đồ đường&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;LINE CHART&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Giúp biểu diễn chuỗi giá trị theo dạng có hình, thường là thông qua diễn tiến thay đổi của thời gian&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;AREA CHART&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Dựa trên Line chart nhưng được fill màu&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;PIE CHART &amp;amp; DONUT CHART&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Biểu diễn mỗi quan hệ giữa các thành phần và tổng thể&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TREE MAP&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Biểu diễn mỗi quan hệ giữa các thành phần và tổng thể, với các hình vuông có màu có kích cỡ riêng biểu thị phần mà các giá trị chiếm.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;CARD &amp;amp; MULTI-ROW CARD&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Card
    &lt;blockquote&gt;
      &lt;p&gt;biểu diễn 1 giá trị&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*Multi-row card&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;dùng để biểu diễn nhiều giá trị&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;GAUGE CHART &amp;amp; KPI&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;được thiết kế để hiển thị dữ liệu thực tế so sánh với dữ liệu ngân sách/doanh thu hoặc mục tiêu đã lên kế hoạch.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;TABLE &amp;amp; MATRIX&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;biểu diễn chi tiết dữ liệu văn bản bằng định dạng Bảng&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;Table:
    &lt;blockquote&gt;
      &lt;p&gt;chứa dữ liệu liên quan trong chuỗi logical của dòng và cột, có thể bao gồm header &amp;amp; footer của bảng&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Matrix:
    &lt;blockquote&gt;
      &lt;p&gt;giống như bảng nhưng matrix có thể thu lại hoặc mở rộng ra bằng dòng hoặc cột&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;HIERARCHIES:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Level data từ cao đến thấp&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ví dụ:
Year =&amp;gt; Quarter =&amp;gt; Month =&amp;gt; Day
Company =&amp;gt; Region =&amp;gt; Country =&amp;gt; DIvision =&amp;gt; Unit&lt;/p&gt;

&lt;p&gt;HÀM:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Là các công thức được định nghĩa trước sẵn để biểu diễn các phép tính trên các giá trị gọi là tham trị &lt;code&gt;arguments&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;2-kiến-thức-nền-tảng-để-visualize-data&quot;&gt;2. Kiến thức nền tảng để visualize data&lt;/h4&gt;

&lt;p&gt;Có 3 cách để lấy được insight của data:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Cách 1: Tính toán thống kê
mean (trung bình), median(trung vị), standard deviation (phương sai)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cách 2: Run model/Chạy mô hình
Linear (Tuyến tính) hoặc hồi quy logistic&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cách 3: Vẽ plot
scatter, bar, histogram (biểu đồ tần suất),…
Scatter plot:
&lt;img src=&quot;img/plot.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;the-datasaurus-dozen&quot;&gt;The Datasaurus Dozen&lt;/h5&gt;

&lt;p&gt;&lt;img src=&quot;img/datasaurus-dozen.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Có 13 datasets, mỗi Dataset có 2 trục x và y được gọi là variable&lt;/li&gt;
  &lt;li&gt;Variable đơn giản chỉ là biệt ngữ thống kê để chỉ cột dữ liệu&lt;/li&gt;
  &lt;li&gt;Khi tính phương sai của mỗi dataset, ta sẽ tính ra 2 phương sai cho x và y trên tất cả các record. Vì dataset trên có 2 giá trị x và y.&lt;/li&gt;
  &lt;li&gt;Phương sai dùng để tính toán sự biến thiên của dữ liệu.&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;chọn-biểu-đồ-chấm-plot-loại-gì-thì-phù-hợp&quot;&gt;Chọn biểu đồ chấm plot loại gì thì phù hợp?&lt;/h5&gt;

&lt;p&gt;Trước tiên phải xác định variable x và y của data thuộc loại nào. Có 3 loại:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Continuous : thường là số và có thể làm các phép toán cho nó.
Ví dụ như nhiệt độ, chiều cao, doanh thu,…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Categorical : thường là dạng văn bản text, những thứ được phân loại hay mô tả.
Ví dụ như màu mắt, quốc gia,…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cả hai loại trên
Ví dụ như tuổi thì dạng continuous, còn nhóm tuổi từ 25-30 thì lại là categorical.
Thời gian thì continuous còn tháng thì categorical.&lt;/p&gt;
    &lt;blockquote&gt;
      &lt;p&gt;Ở đây tùy vào mục đích visualization mà bạn sẽ quyết định nó thuộc loại nào cho phù hợp.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;khi-nào-nên-dùng-biểu-đồ-tần-suất-histogram&quot;&gt;Khi nào nên dùng biểu đồ tần suất Histogram?&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;Nếu bạn có biến continuous như trên&lt;/li&gt;
  &lt;li&gt;Khi bạn muốn biết hình dạng của sự phân tán data, ví dụ như bạn muốn biểu đồ thể hiện rõ giá trị cao nhất và thấp nhất.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Một số thuật ngữ:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Bin (interval) : khoảng cách các ô trục trên biểu đồ, ví dụ 0-5, 5-10,… Nếu muốn rõ data hơn thì ta co bin lại 0-1, 1-2,…
Như hình, bin 10-15 tuổi có giá trị trục y là 4, nghĩa là có 4 người từ 10-15 tuổi.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/histogram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Sự lựa chọn binwidth sẽ ảnh hưởng lớn đến hình ảnh biểu đồ. Dưới đây cho thấy nếu thu nhỏ bin lại còn 1 năm tuổi thì nhìn rất lộn xộn.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/binwidth1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Các tiêu chí trải nghiệm qua để chọn binwidth phù hợp:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Modality : có bao nhiêu đỉnh trong biểu đồ?
Unimodal, bimodal hay trimodal?
&lt;img src=&quot;img/modality.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Skewness: lệch lạc hay cân xứng?
lệch trái, phải hay cân đối ở giữa?
&lt;img src=&quot;img/skewness.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Kurtosis: có bao nhiêu điểm có giá trị = 0? (extreme value) 
&lt;img src=&quot;img/kurtosis.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&quot;khi-nào-nên-vẽ-box-plots&quot;&gt;Khi nào nên vẽ Box Plots?&lt;/h5&gt;
&lt;ul&gt;
  &lt;li&gt;Khi chúng ta có 1 variable là continuous, được tách ra phân loại bởi 1 variable categorical.&lt;/li&gt;
  &lt;li&gt;Khi chúng ta muốn so sánh sự phân tán dữ liệu của variable continuous cho mỗi category (phân loại).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/box-plot.png&quot; alt=&quot;&quot; /&gt;
Các chỉ số trên box plots:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;lower quartile: 1/4 có giá trị dưới số này&lt;/li&gt;
  &lt;li&gt;median : trung vị&lt;/li&gt;
  &lt;li&gt;upper quartile: 1/4 có giá trị trên số này&lt;/li&gt;
  &lt;li&gt;inter-quartile range: khoảng cách từ lower đến upper&lt;/li&gt;
  &lt;li&gt;whiskers: đường thẳng ngang hai bên, đường kẻ ra gấp 1-1,5 lần inter-quarter, dài đến mức độ đủ để biết rằng ngoài đường kẻ thì không có giá trị nào cả (extreme value).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/box-plot-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Phân loại nào chỉ có đường thẳng nghĩa là chỉ có 1 giá trị.&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 23 Jun 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/data-visualization/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/data-visualization/</guid>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>Set-up phpMyAdmin</title>
        <description>&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Initial setup with Ubuntu 20.4: 
https://www.digitalocean.com/community/tutorials/initial-server-setup-with-ubuntu-20-04&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install Mysql on Ubuntu 20.4:
https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-20-04&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install LAMP (Linux, Apache, MySQL, PHP)
https://www.digitalocean.com/community/tutorials/how-to-install-linux-apache-mysql-php-lamp-stack-on-ubuntu-20-04&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Install and Secure phpMyAdmin:
https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-on-ubuntu-20-04&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Secure Apache with Let’s Encrypt on Ubuntu 20.04 (free TLS/SSL certificate)
https://www.digitalocean.com/community/tutorials/how-to-secure-apache-with-let-s-encrypt-on-ubuntu-20-04&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;DOCKER COMPOSE &amp;amp; NETWORK
https://vsudo.net/blog/docker-toan-tap.html&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3&gt; CÓ 2 CÁCH ĐỂ SỬ DỤNG phpMyAdmin:
C1: cài đặt thủ công và sử dụng trên localhost hoặc domain trên server mình host (xem link trên)
https://www.digitalocean.com/community/tutorials/how-to-install-and-secure-phpmyadmin-on-ubuntu-20-04 =&amp;gt; đã thử và ok

C2:dùng Docker network chứa 2 container là MySQL và phpMyAdmin để truy cập MySQL server trên phpMyAdmin host
https://vsudo.net/blog/docker-toan-tap.html =&amp;gt; đã thử và ok

&lt;h3&gt; Cách để đưa db của mình chạy trên container có sẵn của phpMyAdmin
B1: tạo image chạy trên base php cho file .php chứa truy vấn bảng của db (như 1 ứng dụng) và phải cài đặt biến môi trường trong này cho giống với config của container.
B2: compose với container của phpMyAdmin có sẵn (có thể chọn các image phù hợp nhu cầu) và bổ sung image ở trên vào file docker-compose.yml 


--------------------------------------------------


WORKDIR /var/www/tuyen.tech

COPY /etc/apache2/sites-available/tuyen.tech.conf /etc/apache2/sites-available/
COPY /etc/apache2/conf-available/phpmyadmin.conf /etc/apache2/conf-available/
COPY /usr/share/phpmyadmin/.htaccess /usr/share/phpmyadmin/

COPY . /var/www/tuyen.tech/

RUN sudo apt update &amp;amp;&amp;amp; apt install -y \
&amp;amp;&amp;amp; apache2 \
&amp;amp;&amp;amp; php libapache2-mod-php php-mysql \
&amp;amp;&amp;amp; mysql-server \
&amp;amp;&amp;amp; phpmyadmin php-mbstring php-zip php-gd php-json php-curl \
&amp;amp;&amp;amp; phpmyadmin 

RUN sudo mysql_secure_installation \
&amp;amp;&amp;amp; sudo mysql \
&amp;amp;&amp;amp; sudo phpenmod mbstring \
&amp;amp;&amp;amp; sudo htpasswd -c /etc/phpmyadmin/.htpasswd tuyen \
&amp;amp;&amp;amp; sudo systemctl restart apache2 

EXPOSE 9090


--------------------------
FROM ubuntu:latest

MAINTAINER tuyennnt &amp;lt;tuyendev96@gmail.com&amp;gt;
WORKDIR /var/www/tuyen.tech

COPY /etc/apache2/sites-available/tuyen.tech.conf /etc/apache2/sites-available/
COPY /etc/apache2/conf-available/phpmyadmin.conf /etc/apache2/conf-available/
COPY /usr/share/phpmyadmin/.htaccess /usr/share/phpmyadmin/

COPY . /var/www/tuyen.tech/

RUN sudo apt update &amp;amp;&amp;amp; apt install -y \
&amp;amp;&amp;amp; apache2 \
&amp;amp;&amp;amp; php libapache2-mod-php php-mysql \
&amp;amp;&amp;amp; mysql-server \
&amp;amp;&amp;amp; phpmyadmin php-mbstring php-zip php-gd php-json php-curl \
&amp;amp;&amp;amp; phpmyadmin 

RUN sudo mysql_secure_installation \
&amp;amp;&amp;amp; sudo mysql \
&amp;amp;&amp;amp; sudo phpenmod mbstring \
&amp;amp;&amp;amp; sudo htpasswd -c /etc/phpmyadmin/.htpasswd tuyen \
&amp;amp;&amp;amp; sudo systemctl restart apache2 

EXPOSE 9090

&lt;/h3&gt;&lt;/h3&gt;
</description>
        <pubDate>Tue, 15 Jun 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/phpmyadmin/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/phpmyadmin/</guid>
        
        
        <category>Data</category>
        
        <category>Docker</category>
        
      </item>
    
      <item>
        <title>Extract - Transform - Load (ETL process)</title>
        <description>&lt;h1 id=&quot;tìm-hiểu-về-etl&quot;&gt;Tìm hiểu về ETL&lt;/h1&gt;

&lt;h2 id=&quot;i-extract-data&quot;&gt;I. EXTRACT DATA&lt;/h2&gt;

&lt;h3 id=&quot;1-các-cách-để-trích-xuất-dữ-liệu&quot;&gt;1. Các cách để trích xuất dữ liệu&lt;/h3&gt;
&lt;p&gt;Có 3 cách:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/extract.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Trích xuất từ file text, như file .txt or .csv
Text file có 3 loại là : 
	* Text thuần
	* Flat file (là file có .tsv hoặc .csv cách nhau bởi dấu “,” hoặc “tab” giữa các giá trị). Những file này có dòng thể hiện các record và cột thể hiện attribute của record.
	*File JSON: bán cấu trúc, có 4 kiểu dữ liệu atomic là number, string, boolean và null và 2 kiểu dữ liệu dạng composite là array và object.
	JSON có package hỗ trợ là “json” để import data
	&lt;img src=&quot;img/load-json.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Trích xuất từ web hoặc APIs của web services, như là Hacker News API
&lt;img src=&quot;img/web-extract.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Thông qua web:&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;&lt;img src=&quot;img/data-web.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ví dụ: bạn tìm kiếm thông tin trên google.com thì trình duyệt của bạn sẽ gửi request của bạn đến server của google và google sẽ trả về dữ liệu mà bạn đang tìm kiếm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;* Thông qua API của web:
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Không phải lúc nào các trang web cũng trả về kết quả mà người thường có thể đọc ngay, mà các trang web đó sẽ trả về định dạng JSON thông qua API mà chúng ta request.&lt;/p&gt;

&lt;p&gt;Ta xem ví dụ request API từ trang Hackernews:
&lt;img src=&quot;img/api-request.png&quot; alt=&quot;&quot; /&gt;
Ta import package “request” rồi dùng method .get() để chèn vào link web cần lấy file JSON. 
Sau đó ta dùng method .json() để phân tích file JSON từ kết quả đã lấy được và chuyển hóa nó thành Python object.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Trích xuất từ một database trên web services 
Hầu hết các ứng dụng web đều có database để backup và để không bị ảnh hưởng khi tắt server, v.v. Cần phân biệt 2 loại database chính trong trường hợp này:
    &lt;ul&gt;
      &lt;li&gt;&lt;em&gt;Application database&lt;/em&gt; : dùng cho trường hợp có nhiều giao dịch được cập nhật, loại này còn có tên gọi là &lt;em&gt;OLTP&lt;/em&gt; (online transaction processing)&lt;/li&gt;
      &lt;li&gt;&lt;em&gt;Analytical database&lt;/em&gt;: được xây dựng cho việc phân tích dữ liệu còn gọi là &lt;em&gt;OLAP&lt;/em&gt; (online analytical processing)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-trích-xuất-dữ-liệu-từ-database-như-thế-nào&quot;&gt;2. Trích xuất dữ liệu từ database như thế nào?&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Dùng URI/chuỗi connection, cú pháp như sau:
    &lt;pre&gt;&lt;code&gt;[database_type]://[user[:password]@][host][:port]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;Trong Python, ta dùng connection URI thông qua package &lt;code&gt;sqlalchemy&lt;/code&gt; để tạo &lt;em&gt;database engine&lt;/em&gt; :&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;img/create-engine.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Từ engine đã được tạo ra, ta có thể dùng nó để đặt vào 1 số package hỗ trợ nó tương tác với database, đặc biệt là package &lt;code&gt;pandas&lt;/code&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;import requests
```&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;lấy-dữ-liệu-từ-bài-viết-của-hackernews-về-f12-inspect-để-lấy-url-của-nó&quot;&gt;Lấy dữ liệu từ bài viết của Hackernews về, F12 inspect để lấy URL của nó&lt;/h1&gt;
&lt;p&gt;resp = requests.get(“https://hacker-news.firebaseio.com/v0/item/16222426.json”)&lt;/p&gt;

&lt;h1 id=&quot;in-dữ-liệu-vừa-parse-thành-file-json-ra-màn-hình&quot;&gt;in dữ liệu vừa parse thành file json ra màn hình&lt;/h1&gt;
&lt;p&gt;print(resp.json())&lt;/p&gt;

&lt;h1 id=&quot;parse-dữ-liệu-ra-rồi-gán-value-của-key-score-vào-biến-post_score-sau-đó-in-cái-biến-ra&quot;&gt;parse dữ liệu ra rồi gán value của key “score” vào biến post_score, sau đó in cái biến ra&lt;/h1&gt;
&lt;p&gt;post_score = resp.json()[“score”]
print(post_score)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;

* Một số ví dụ mở rộng hơn (xem phần 3 để hiểu hơn):

Đọc dữ liệu từ database của postgreSQL, hàm extract dùng SQL query có nhiệm vụ chuyển từ dữ liệu bảng thành kiểu object mà pandas dùng (là dataframe)

&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;function-to-extract-table-to-a-pandas-dataframe&quot;&gt;Function to extract table to a pandas DataFrame&lt;/h1&gt;
&lt;p&gt;def extract_table_to_pandas(tablename, db_engine):
    query = “SELECT * FROM {}”.format(tablename)
    return pd.read_sql(query, db_engine)&lt;/p&gt;

&lt;h1 id=&quot;connect-to-the-database-using-the-connection-uri-sử-dụng-package-sqlalchemy&quot;&gt;Connect to the database using the connection URI, sử dụng package sqlalchemy&lt;/h1&gt;
&lt;p&gt;connection_uri = “postgresql://repl:password@localhost:5432/pagila” 
db_engine = sqlalchemy.create_engine(connection_uri)&lt;/p&gt;

&lt;h1 id=&quot;extract-the-film-table-into-a-pandas-dataframe-lưu-ý-nhớ-để-tên-bảng-dạng-chuỗi&quot;&gt;Extract the film table into a pandas DataFrame, lưu ý nhớ để tên bảng dạng chuỗi&lt;/h1&gt;
&lt;p&gt;extract_table_to_pandas(“film”, db_engine)&lt;/p&gt;

&lt;h1 id=&quot;extract-the-customer-table-into-a-pandas-dataframe&quot;&gt;Extract the customer table into a pandas DataFrame&lt;/h1&gt;
&lt;p&gt;extract_table_to_pandas(“customer”, db_engine)
```&lt;/p&gt;

&lt;h2 id=&quot;2-transform-data&quot;&gt;2. TRANSFORM DATA&lt;/h2&gt;
&lt;h3 id=&quot;1-một-số-phương-thức-chuyển-đổi-dữ-liệu&quot;&gt;1. Một số phương thức chuyển đổi dữ liệu&lt;/h3&gt;
&lt;p&gt;Có thể thực hiện 1 hoặc nhiều các hình thức trong giai đoạn chuyển đổi dữ liệu đã rút trích:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Select 1 hay nhiều cột&lt;/li&gt;
  &lt;li&gt;Phiên dịch dữ liệu thành code. Ví dụ như New York sẽ biến thành NY&lt;/li&gt;
  &lt;li&gt;Kiểm tra dữ liệu có đúng không, nếu dữ liệu không đúng với kiểu dữ liệu hoặc dữ liệu muốn nhận từ cột, ta có thể bỏ record đó đi. Ví dụ như cột ngày nhưng lại chứa giá trị khác ngày.&lt;/li&gt;
  &lt;li&gt;Tách dữ liệu của 1 cột thành nhiều cột&lt;/li&gt;
  &lt;li&gt;Join dữ liệu từ các nguồn, các bảng khác nhau.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;2-một-số-ví-dụ&quot;&gt;2. Một số ví dụ&lt;/h3&gt;

&lt;p&gt;Bạn có thể dùng package &lt;code&gt;pandas&lt;/code&gt; để chuyển đổi dữ liệu nếu lượng dữ liệu nhỏ. Ta có ví dụ tách dữ liệu từ 1 cột thành 2 cột sử dụng pandas:
&lt;img src=&quot;img/split-pandas.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Nếu dữ liệu lớn, thông thường người ta sẽ dùng &lt;strong&gt;PySpark&lt;/strong&gt;. Ta có ví dụ chuyển đổi dữ liệu bằng cách join các bảng với nhau. 
Nhưng trước hết chúng ta cần đẩy dữ liệu lên Spark:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/extract-pyspark.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;jbdc:&lt;/code&gt;để nhắn nhủ với Spark là phải dùng JBDC để kết nối, sau đó, ta input vào tên của bảng và cuối cùng trong &lt;code&gt;properties&lt;/code&gt; chúng ta đặt thông tin kết nối vào.&lt;/p&gt;

&lt;p&gt;Dưới đây là 2 bảng cần join với nhau thông qua &lt;code&gt;customer_id&lt;/code&gt; để tính rating trung bình của mỗi customer dành cho các phim:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/rating-join.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Và làm sao để dùng PySpark join và tính toán dữ liệu? Xem ảnh dưới nhé:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;img/join-pyspark.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Mình sẽ cho ra thêm các bài viết tìm hiểu sâu hơn về PySpark trong thời gian tới, các bạn hãy cùng chờ đợi nhé!&lt;/p&gt;

&lt;h2 id=&quot;iii-load-data&quot;&gt;III. LOAD DATA&lt;/h2&gt;

</description>
        <pubDate>Sat, 29 May 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/data-etl/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/data-etl/</guid>
        
        
        <category>Data</category>
        
      </item>
    
      <item>
        <title>React Native - CSS rules</title>
        <description>&lt;p&gt;Phân biệt các attribute quan trọng sau để build giao diện trong react native:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;flexDirection: “row” hoặc “column”&lt;/li&gt;
  &lt;li&gt;justify-content : “center”
main/primary axis phụ thuộc vào flexDirection, ta có space-evenly&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;align-items : “center”
căn chỉnh secondary axis cho mỗi line, có các loại như center, baseline,…&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;flexWrap: “wrap” 
để các component ko bị chèn ép mất đi&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;align-Content : căn chỉnh toàn bộ nội dung của 1 block trên secondary axis, chỉ hoạt động khi có flexWrap.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;align-self&lt;/li&gt;
  &lt;li&gt;flex: 1&lt;/li&gt;
  &lt;li&gt;flexBasis: 100,
 //width (nếu main là row) or height, phụ thuộc vào primary axis (main)&lt;/li&gt;
  &lt;li&gt;flexGrow: 1 
 //giống flex : 1, trải ra đầy màn hình&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;flexShrink: 1
 //giống flex : -1, co lại để ko tràn màn hình&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bottom, right, left, top : di chuyển qua trái, phải bao nhiêu pixel&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;position: “absolute” hoặc “relative”
 //giá trị mặc định trong react native là “relative”&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*Dimensions: import thư viện này trong react
 DIP công thức như sau:
 Physical Pixels = DIPs x Scale Factor
 vd điện thoại có scale là 2 và point điểm ảnh là 320x480 thì View đối với Width có giá trị 150 là 150x2=300
 =&amp;gt; nghĩa là bề ngang là 1/2 màn hình
 &lt;img src=&quot;img/dip-react.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 24 May 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/react-native-css/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/react-native-css/</guid>
        
        
        <category>React</category>
        
        <category>App</category>
        
      </item>
    
      <item>
        <title>Basics of Docker</title>
        <description>&lt;h4 id=&quot;cách-run-ubuntu&quot;&gt;Cách RUN UBUNTU&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;docker  run ubuntu&lt;/code&gt;
 //nếu chưa pull ubuntu image về thì sẽ pull rồi start, còn nếu pull rồi thì nó sẽ start container này luôn 
 =&amp;gt; nếu khi start mà thấy chưa có interact gì thì nó sẽ stop container lại luôn&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker ps&lt;/code&gt;
 //xem list các tiến trình đang chạy của container hoặc các container đang chạy&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker ps -a&lt;/code&gt;
 //xem các container đã dừng lại&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker run -it ubuntu&lt;/code&gt;
 // start container với interaction mode và load ubuntu image lên trong cái container này&lt;/p&gt;

&lt;p&gt;Các câu lệnh:
 &lt;code&gt;history&lt;/code&gt;
 &lt;code&gt;!2&lt;/code&gt; //để output cmd thứ 2 trong list history
 &lt;code&gt;ls -1&lt;/code&gt;
 //líst ds theo dạng dọc&lt;/p&gt;

&lt;p&gt;&lt;code&gt;ls -l&lt;/code&gt;
 //list ds chi tiet&lt;/p&gt;

&lt;p&gt;&lt;code&gt;touch &amp;lt;tên file&amp;gt;&lt;/code&gt;
 //lệnh tạo file&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mkdir &amp;lt;tên thư mục&amp;gt;&lt;/code&gt;
 //lệnh tạo thư mục&lt;/p&gt;

&lt;p&gt;&lt;code&gt;mv &amp;lt;tên file hoặc địa chỉ&amp;gt; &amp;lt;tên file hoặc địa chỉ&amp;gt;&lt;/code&gt;
 //đổi tên hoặc di chuyển&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cat &amp;lt;tên file&amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;more &amp;lt;tên file hoặc địa chỉ&amp;gt;&lt;/code&gt;
 //xem nội dung theo từng page, bấm phím space để qua trang tiếp theo nhưng ko scroll up lên được, nhấn enter để chạy từng line để xem&lt;/p&gt;

&lt;p&gt;&lt;code&gt;less &amp;lt;tên file hoặc địa chỉ&amp;gt;&lt;/code&gt;
 //&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cat &amp;lt;tên file&amp;gt; &amp;gt; &amp;lt;tên file khác&amp;gt;&lt;/code&gt;
//copy nội dung file này vào file khác&lt;/p&gt;

&lt;p&gt;&lt;code&gt;cat &amp;lt;tên file&amp;gt; &amp;lt;tên file khác&amp;gt; &amp;gt; &amp;lt;tên combined file&amp;gt;&lt;/code&gt;	
//combine nội dung 2 file vào file khác&lt;/p&gt;

&lt;p&gt;dấu &lt;code&gt;&amp;gt;&lt;/code&gt; áp dụng cho hầu hết các câu lệnh
vd: echo hello &amp;gt; hello.txt
ls -l /etc &amp;gt; hello.txt
sẽ cho kết quả ra file hello.txt trên.&lt;/p&gt;

&lt;p&gt;Trong Linux, mọi thứ đều ở duới dangj file, từ process, devices, hoặc địa chỉ thư mục đều là files&lt;/p&gt;

&lt;p&gt;Cấu trúc Linux:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/&lt;/li&gt;
  &lt;li&gt;bin: chưa các file binaries, chương trình&lt;/li&gt;
  &lt;li&gt;boot: các file liên quan booting&lt;/li&gt;
  &lt;li&gt;dev: devices&lt;/li&gt;
  &lt;li&gt;etc: editable text configuration, chứa file config&lt;/li&gt;
  &lt;li&gt;home: thư mục của user&lt;/li&gt;
  &lt;li&gt;root: chỉ có root mới vào được thư mục này&lt;/li&gt;
  &lt;li&gt;lib: libary files như software library dependencies&lt;/li&gt;
  &lt;li&gt;var: như biến, chứa các file được update thường xuyên như log,…&lt;/li&gt;
  &lt;li&gt;proc: chứa các tiến trình đang running&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;các-bước-để-sử-dụng-docker&quot;&gt;Các bước để sử dụng Docker&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Cài đặt Docker&lt;/li&gt;
  &lt;li&gt;Tạo 1 program và Tạo file plain text Dockerfile ghi hướng dẫn để đưa cho docker đóng gói ứng dụng thành 1 image. Image chứa tất cả mọi thứ để chương trình chạy.
 IMAGE bao gồm:
    &lt;ul&gt;
      &lt;li&gt;A cut-down OS&lt;/li&gt;
      &lt;li&gt;Môi trường runtime (vd như Node, Python)&lt;/li&gt;
      &lt;li&gt;File ứng dụng&lt;/li&gt;
      &lt;li&gt;Thư viện thứ 3&lt;/li&gt;
      &lt;li&gt;Biến môi trường
 =&amp;gt; Sau khi có cái Image này, ta sẽ nói với Docker để start container 
 Container như 1 process, nhưng là process đăc biệt vì nó có file system được cung cấp bởi Image. Ứng dụng của chúng ta sẽ được chạy trong cái process/container này.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ok giờ chúng ta start docker.
 Thay vì chạy ứng dụng như bình thường, ta gọi Docker để chạy bên trong cái container nhé&lt;/p&gt;

&lt;p&gt;&lt;code&gt;docker run ..&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ví dụ sự khác nhau :&lt;/p&gt;

&lt;p&gt;Để chạy 1 chương trình JS đơn giản, ta cần phải qua 4 bước:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Start OS&lt;/li&gt;
  &lt;li&gt;Cài Node&lt;/li&gt;
  &lt;li&gt;Copy file ứng dụng&lt;/li&gt;
  &lt;li&gt;Chạy &lt;code&gt;node app.js&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Với docker, ta chỉ cần:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Bước 1:&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Vào thư mục project trên vscode &lt;code&gt;code .&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Tạo file &lt;code&gt;Dockerfile&lt;/code&gt; không ext, và input các thông tin sau:
 ```
 FROM node:alpine
    &lt;blockquote&gt;
      &lt;p&gt;chọn image node trên trang docker hub và : distribution của linux, ở đây chọn alpine vì nó nhẹ nhất 
 COPY . /app 
copy tất cả file execute vào thư mục app tạo mới, vào rồi copy vào trong image
hoặc có thể hiểu là trong cái image có file system, và chúng ta tạo thư mục app bên trong file system đó, trong thư mục app chứa tất cả các file của program
 WORKDIR /app
tạo đường dẫn rút gọn
 CMD node /app.js
câu lệnh chạy ứng dụng, để docker biết mà chạy câu nào khi run&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;Bước 2:&lt;/li&gt;
  &lt;li&gt;TA nói docker đóng gói úng dụng thành image
 &lt;code&gt;docker build -t hello-docker .&lt;/code&gt;
 trong đó, dấu . chỉ cho docker biết chỗ nào chứa Dockerfile
 hello-docker là tên repos docker mình tự tạo để quản lý&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Để xem có bao nhiêu docker đang chạy:
 &lt;code&gt;docker image ls&lt;/code&gt;
 kết quả câu lệnh có cột SIZE chỉ size của OS (alpine) + ứng dụng + node&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BƯớc 3:
 Chạy thử docker image
 &lt;code&gt;docker run hello-docker&lt;/code&gt;
 ta có thể chạy ở thư mục nào cũng được, vì image đã chứa mọi thứ cần&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*BƯớc 4
 Publish lên docker hub hub.docker.com&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;KHi ở máy khác, ta muốn pull image về chạy:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;BƯớc 1:&lt;/li&gt;
  &lt;li&gt;Kiểm tra version docker, nếu chưa download thì chạy lệnh install
 &lt;code&gt;docker vesion&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;*Bước 2:
 Kéo image về
 &lt;code&gt;docker pull senrie/hello-docker&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Kiểm tra lại = cách:
 &lt;code&gt;docker image ls&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;*Bước 3:
 Chạy chương trình trên machine 
 &lt;code&gt;docker run senrie/hello-docker&lt;/code&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 02 May 2021 00:00:00 +0700</pubDate>
        <link>/tuyen-nnt.github.io/docker/</link>
        <guid isPermaLink="true">/tuyen-nnt.github.io/docker/</guid>
        
        
        <category>Docker</category>
        
      </item>
    
  </channel>
</rss>
